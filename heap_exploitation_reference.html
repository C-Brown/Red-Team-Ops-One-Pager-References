<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Heap Exploitation (Windows) Reference</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}body{background:#08090c;color:#e5e7eb;font-family:'Segoe UI',system-ui,sans-serif;min-height:100vh}.mono{font-family:'Cascadia Code','IBM Plex Mono','Fira Code',monospace}.off{color:#ef4444;font-weight:600;font-size:.82em}.hd{padding:10px 14px 0;border-bottom:1px solid #1a1d27;background:linear-gradient(180deg,#0c0e14,#08090c)}.hd h1{font-size:1em;font-weight:800;background:linear-gradient(135deg,#f472b6,#f59e0b,#34d399);-webkit-background-clip:text;-webkit-text-fill-color:transparent}.hd .sub{font-size:.62em;color:#374151}.st{display:flex;gap:1px;overflow-x:auto;flex-wrap:wrap}.sb{padding:4px 7px;border:none;cursor:pointer;border-radius:6px 6px 0 0;font-size:.66em;font-weight:600;white-space:nowrap;background:transparent;color:#374151;border-bottom:2px solid transparent;transition:all .15s}.sb.on{background:#111318}.sb[data-sc="kit"],.sb[data-sc="byp"]{border-left:2px solid #ffffff15;margin-left:4px}.ut{padding:0 14px;background:#0a0b10;border-bottom:1px solid #1a1d27;display:flex}.ub{padding:7px 12px;border:none;cursor:pointer;font-size:.7em;font-weight:600;background:transparent;color:#4b5563;border-bottom:2px solid transparent;display:flex;align-items:center;gap:4px}.ub.on{color:#e5e7eb;border-bottom-color:#e5e7eb}.cnt{font-size:.82em;background:#1f2937;padding:0 4px;border-radius:6px;color:#9ca3af}.ct{padding:10px 14px;overflow-x:auto}.fr{display:flex;align-items:flex-start;gap:0;overflow-x:auto;padding:8px 0}.ar{display:flex;align-items:center;padding:0 4px;flex-shrink:0}.ar .ln{width:24px;height:2px;background:linear-gradient(90deg,#4b5563,#9ca3af)}.ar .tp{color:#9ca3af;font-size:13px;margin-left:-2px}.ar .lb{font-size:.62em;color:#6b7280;margin-left:3px;white-space:nowrap}.bx{background:#0d0f14;border-radius:8px;flex-shrink:0;overflow:hidden}.bx-h{padding:6px 10px;font-weight:700;font-size:.8em}.bx-s{font-size:.65em;color:#4b5563;margin-top:1px}.bx-b{padding:6px 10px}.fd{display:flex;gap:6px;padding:1.5px 0;font-size:.78em;align-items:baseline}.fd.hl{background:#ffffff08;border-radius:3px;padding:2px 4px}.fd .tp{color:#6b7280;font-size:.82em}.tg{display:inline-block;padding:1px 7px;border-radius:4px;font-size:.78em;font-weight:700}.tg-s{padding:0 5px;font-size:.68em}.nt{margin:6px 0;padding:7px 10px;border-radius:6px}.nt .nl{font-size:.6em;font-weight:800;letter-spacing:.08em;margin-bottom:2px}.nt .nb{color:#d1d5db;font-size:.78em;line-height:1.4}.cp{border:1px solid #1f2937;border-radius:8px;overflow:hidden;margin-bottom:6px}.ct2{width:100%;padding:8px 12px;border:none;cursor:pointer;text-align:left;background:#0d0f14;display:flex;align-items:center;gap:8px}.ct2:hover{background:#111827}.cv{color:#6b7280;font-size:12px;transition:transform .15s;display:inline-block}.cv.op{transform:rotate(90deg)}.ct2 .tl{color:#e5e7eb;font-size:.8em;font-weight:600;flex:1}.cb{margin:0;padding:10px 14px;background:#080a0f;font-size:.74em;line-height:1.5;color:#a5f3fc;overflow-x:auto;border-top:1px solid #1f2937;white-space:pre;tab-size:4}.cb .cm{color:#4b5563}.cb .pp{color:#f59e0b}.ti{border-radius:6px;overflow:hidden;border:1px solid #1f2937;background:#0a0c10;margin-bottom:3px}.ti.op{border-color:#f9731640;background:#f9731608}.tt{width:100%;padding:6px 10px;border:none;cursor:pointer;text-align:left;background:transparent;display:flex;align-items:center;gap:6px}.tt .tn{font-size:.78em;font-weight:600;color:#9ca3af}.ti.op .tn{color:#fdba74}.td{padding:4px 10px 8px 26px;color:#d1d5db;font-size:.76em;line-height:1.5}.nb2{padding:2px 6px;border:1px solid #1f2937;border-radius:4px;cursor:pointer;background:#0d0f14;color:#4b5563;font-size:.65em}.ft{padding:8px 14px;border-top:1px solid #1a1d27;display:flex;gap:8px;flex-wrap:wrap;font-size:.6em}.dt{width:6px;height:6px;border-radius:2px;display:inline-block}.grd{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:8px}
</style>
</head>
<body>
<div id="app"></div>
<script>
var $=function(s){return document.querySelector(s)};
var $$=function(s){return Array.prototype.slice.call(document.querySelectorAll(s))};
function esc(s){return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}
var SE=[
{id:"arc",l:"A. Heap Architecture",i:"\u{1F3D7}\uFE0F",c:"#f472b6"},
{id:"nt",l:"B. NT Heap (Legacy)",i:"\u{1F4E6}",c:"#60a5fa"},
{id:"seg",l:"C. Segment Heap",i:"\u{1F9F1}",c:"#a78bfa"},
{id:"lfh",l:"D. LFH Internals",i:"\u{1F4CA}",c:"#34d399"},
{id:"uaf",l:"E. Use-After-Free",i:"\u{1F47B}",c:"#f87171"},
{id:"ovf",l:"F. Overflow / OOB",i:"\u{1F4A5}",c:"#fbbf24"},
{id:"prim",l:"G. Primitives",i:"\u{1F527}",c:"#f59e0b"},
{id:"kit",l:"H. Toolkit",i:"\u{1F9F0}",c:"#e879f9"},
{id:"mit",l:"I. Mitigations",i:"\u{1F6E1}\uFE0F",c:"#fb923c"}
];
var S={s:'arc',t:'flow'};
function T(t,c,s){return '<span class="tg'+(s?' tg-s':'')+'\" style=\"background:'+c+'18;color:'+c+';border:1px solid '+c+'30\">'+t+'</span>'}
function A(l){return '<div class="ar"><div class="ln"></div><div class="tp">&#9658;</div>'+(l?'<div class="lb">'+l+'</div>':'')+'</div>'}
function B(t,c,b,w,s){return '<div class="bx" style="min-width:'+(w||220)+'px;max-width:'+(w?w+100:330)+'px;border:1px solid '+c+'35"><div class="bx-h" style="color:'+c+';border-bottom:1px solid '+c+'20;background:linear-gradient(135deg,'+c+'12,'+c+'05)">'+t+(s?'<div class="bx-s">'+s+'</div>':'')+'</div><div class="bx-b">'+b+'</div></div>'}
function F(o,n,t,hl){return '<div class="fd'+(hl?' hl':'')+'\">'+(o?'<code class="mono off">'+o+'</code> ':'')+' <span style="flex:1">'+n+'</span>'+(t?'<span class="tp mono">'+t+'</span>':'')+'</div>'}
function N(l,c,b){return '<div class="nt" style="background:'+c+'08;border:1px solid '+c+'25"><div class="nl" style="color:'+c+'">'+l+'</div><div class="nb">'+b+'</div></div>'}
function CRD(icon,title,color,body){return '<div style="border-radius:8px;border:1px solid '+color+'25;background:'+color+'06;overflow:hidden"><div style="padding:8px 10px;color:'+color+';border-bottom:1px solid '+color+'15;font-weight:700;font-size:.76em">'+icon+' '+title+'</div><div style="padding:8px 10px;font-size:.72em;color:#d1d5db;line-height:1.5">'+body+'</div></div>'}
function fARC(){
var h='<div style="font-size:.72em;font-weight:800;color:#f472b6;letter-spacing:.06em;margin-bottom:6px">WINDOWS HEAP ARCHITECTURE OVERVIEW</div>';
h+='<div class="fr">';
h+=B("Application","#f472b6",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","malloc() / HeapAlloc() / new","")+F("","RtlAllocateHeap (ntdll)","")+F("","Size + flags determine path","")+'</div>',200);
h+=A("dispatch");
h+=B("Front End","#f472b6",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","LFH (Low Fragmentation Heap)","")+F("","Handles sizes 1\u201316368 bytes","")+F("","Fixed-size buckets, fast alloc","")+F("","Activated after 17+ allocs of same size","")+'</div>',250);
h+=A("fallback");
h+=B("Back End","#f472b6",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","NT Heap: FreeLists, segments, VirtualAlloc","")+F("","Segment Heap: VS, LFH, Large segments","")+F("","Manages actual virtual memory","")+'</div>',240);
h+='</div>';
h+='<div class="grd" style="margin-top:8px">';
h+=CRD("\u{1F3D7}\uFE0F","Two Heap Implementations","#f472b6",F("","NT Heap (Legacy): default for most Win32 apps","")+F("","Segment Heap: default for UWP, system processes, Edge","")+F("","Win10 RS5+: apps can opt-in to Segment Heap","")+F("","Win11: Segment Heap default for more processes","")+F("","Both coexist; which is active depends on the process",""));
h+=CRD("\u{1F4CA}","Heap Handle (_HEAP)","#f472b6",F("","GetProcessHeap() returns default heap","")+F("","HeapCreate() for private heaps","")+F("","_HEAP structure: front-end, back-end, metadata","")+F("","Encoding: heap cookies XOR metadata fields","")+F("","Multiple heaps per process common (CRT, COM, etc.)",""));
h+=CRD("\u{1F4A7}","Allocation Size Classes","#f472b6",F("","< 16368 bytes: LFH eligible (front-end)","")+F("","< 508KB (NT) / < 128KB (Seg): back-end managed","")+F("","Larger: direct VirtualAlloc","")+F("","LFH buckets: 128 size classes (8-byte granularity)","")+F("","Size class = (size + 0xF) >> 4 (for NT Heap)",""));
h+=CRD("\u{1F510}","Heap Metadata Encoding","#f472b6",F("","_HEAP.Encoding: random cookie per heap","")+F("","Chunk headers XOR'd with cookie","")+F("","Prevents direct metadata tampering","")+F("","Must leak or guess cookie to forge headers","")+F("","LFH uses separate bitmap encoding",""));
h+='</div>';return h;
}
function fNT(){
var h='<div style="font-size:.72em;font-weight:800;color:#60a5fa;letter-spacing:.06em;margin-bottom:6px">NT HEAP (LEGACY) INTERNALS</div>';
h+='<div class="grd">';
h+=CRD("\u{1F4E6}","_HEAP_ENTRY (Chunk Header)","#60a5fa",F("+0x00","Size (encoded, 8-byte units)","")+F("+0x02","Flags (BUSY=0x01, EXTRA=0x02, FILL=0x04)","")+F("+0x03","SmallTagIndex (debug fill)","")+F("+0x04","PreviousSize (encoded, 8-byte units)","")+F("+0x08","SegmentOffset / UnusedBytes","")+F("","Header is 16 bytes (0x10), precedes user data","")+F("","All fields XOR'd with _HEAP.Encoding",""));
h+=CRD("\u{1F504}","Free Lists","#60a5fa",F("","Free chunks organized in doubly-linked lists","")+F("","ListHints[]: array indexed by size bucket","")+F("","Free chunk: Flink/Blink in user data area","")+F("","Coalescing: adjacent free chunks merge","")+F("","Classic unlink: Flink->Blink = Blink; Blink->Flink = Flink",""));
h+=CRD("\u{1F9F1}","Segments","#60a5fa",F("","_HEAP_SEGMENT: contiguous virtual memory block","")+F("","Default heap segment: 64KB\u20131MB initial","")+F("","Grows by committing more pages from reservation","")+F("","Multiple segments per heap possible","")+F("","UCR (UnCommittedRange): tracks uncommitted regions",""));
h+=CRD("\u{1F3AF}","Back-End Allocation Flow","#60a5fa",F("1.","Check FreeList for exact or larger chunk","")+F("2.","Split if larger: return requested, remainder to FreeList","")+F("3.","If no chunk: extend segment (commit more pages)","")+F("4.","If segment full: create new segment","")+F("5.","If too large: VirtualAlloc directly",""));
h+=CRD("\u{1F50D}","Classic Unlink Exploitation","#60a5fa",F("","Free: removes chunk from FreeList","")+F("","Unlink: Flink->Blink = Blink; Blink->Flink = Flink","")+F("","If metadata corrupted: arbitrary 8-byte write","")+F("","Heavily mitigated: safe unlink checks (Win XP SP2+)","")+F("","Modern: need to bypass encode + safe unlink",""));
h+='</div>';return h;
}
function fSEG(){
var h='<div style="font-size:.72em;font-weight:800;color:#a78bfa;letter-spacing:.06em;margin-bottom:6px">SEGMENT HEAP INTERNALS</div>';
h+='<div class="grd">';
h+=CRD("\u{1F9F1}","Architecture","#a78bfa",F("","_SEGMENT_HEAP replaces _HEAP for enabled processes","")+F("","Three allocation backends:","")+F("","  VS (Variable Size): 1\u2013512 bytes","",true)+F("","  LFH: 512\u201316368 bytes","",true)+F("","  Large: >128KB (direct segment allocation)","",true)+F("","Each backend has distinct metadata and free-list structures",""));
h+=CRD("\u{1F4A7}","Variable Size (VS) Allocations","#a78bfa",F("","VS Subsegments: 64KB pages subdivided","")+F("","_HEAP_VS_CHUNK_HEADER: 16 bytes","")+F("+0x00","Sizes (encoded: AllocatedSize + UnsafeSize)","")+F("+0x08","EncodedSegmentPageOffset + UnusedBytes","")+F("","Free VS chunks on _HEAP_VS_CONTEXT.FreeChunkTree (RB tree)","")+F("","Allocation: best-fit from RB tree",""));
h+=CRD("\u{1F4CA}","Segment Heap LFH","#a78bfa",F("","Separate from NT Heap LFH (different implementation)","")+F("","_HEAP_LFH_CONTEXT per bucket","")+F("","_HEAP_LFH_SUBSEGMENT: page-sized, holds fixed-size slots","")+F("","Bitmap: tracks free/busy slots in subsegment","")+F("","Allocation order randomized within subsegment",""));
h+=CRD("\u{1F510}","Encoding & Security","#a78bfa",F("","VS chunk headers XOR'd with LfhKey from _SEGMENT_HEAP","")+F("","RtlpHpHeapGlobals: global encoding keys","")+F("","Guard pages between segments","")+F("","Block padding: random bytes after allocation","")+F("","Harder to exploit than NT Heap: more metadata checks",""));
h+=CRD("\u{1F527}","VS Free Tree Manipulation","#a78bfa",F("","Free VS chunks: Red-Black tree by size","")+F("","Tree node in freed chunk user data","")+F("","Corrupt tree node \u2192 arbitrary address returned on alloc","")+F("","Requires: overflow into free chunk tree pointers","")+F("","Mitigated: encoding, node validation",""));
h+='</div>';
h+=N("WHICH HEAP?","#a78bfa","Check with WinDbg: <b>!heap -s</b> shows heap type. <b>dt ntdll!_SEGMENT_HEAP</b> for Segment Heap processes. Most exploitation targets know which heap their target uses. Edge, UWP, system services use Segment Heap. Most Win32 apps still use NT Heap.");
return h;
}
function fLFH(){
var h='<div style="font-size:.72em;font-weight:800;color:#34d399;letter-spacing:.06em;margin-bottom:6px">LOW FRAGMENTATION HEAP (LFH) INTERNALS</div>';
h+='<div class="grd">';
h+=CRD("\u{1F4CA}","LFH Activation","#34d399",F("","LFH activates per-size-class after 17+ allocs of same size","")+F("","Or: HeapSetInformation(HeapCompatibilityInformation = 2)","")+F("","Once active: all allocs of that size go through LFH","")+F("","Cannot deactivate per-size once enabled","")+F("","Attacker can force activation by spraying allocations",""));
h+=CRD("\u{1F9F1}","Subsegment Layout","#34d399",F("","_HEAP_SUBSEGMENT: manages a pool of fixed-size blocks","")+F("","_HEAP_USERDATA_HEADER: metadata at subsegment start","")+F("","Blocks: contiguous slots of BlockSize bytes","")+F("","BusyBitmap: tracks which slots are allocated","")+F("","FreeHint: index to start searching for free slots",""));
h+=CRD("\u{1F500}","Randomized Allocation Order","#34d399",F("","Win8+: LFH randomizes allocation order within subsegment","")+F("","Not sequential: slot N+1 doesn't follow slot N","")+F("","Breaks classic heap spray adjacent-allocation assumption","")+F("","Mitigation against: overflow into adjacent chunk","")+F("","Workaround: spray heavily + statistical expectation",""));
h+=CRD("\u{1F3AF}","Bitmap Manipulation","#34d399",F("","BusyBitmap: bit per slot (1=busy, 0=free)","")+F("","Corrupting bitmap: make busy slot appear free","")+F("","Result: overlapping allocations (two pointers, one slot)","")+F("","Can read/write through overlap","")+F("","Requires: adjacent overflow reaching bitmap",""));
h+=CRD("\u{1F50D}","Subsegment vs Backend","#34d399",F("","LFH subsegment is carved from backend allocation","")+F("","Subsegment header + N fixed-size blocks","")+F("","When subsegment full: new subsegment allocated","")+F("","Backend provides the virtual memory pages","")+F("","Attacking subsegment metadata vs attacking chunk data: different strategies",""));
h+='</div>';return h;
}
function fUAF(){
var h='<div style="font-size:.72em;font-weight:800;color:#f87171;letter-spacing:.06em;margin-bottom:6px">USE-AFTER-FREE EXPLOITATION</div>';
h+='<div class="fr">';
h+=B("Allocate Object","#f87171",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","Object A allocated on heap","")+F("","Contains: vtable ptr, data fields","")+F("","Pointer to A saved somewhere","")+'</div>',200);
h+=A("free");
h+=B("Free (Bug)","#f87171",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","Object A freed","")+F("","Pointer to A NOT cleared (dangling)","")+F("","Memory returned to free list","")+'</div>',220);
h+=A("reclaim");
h+=B("Reclaim Slot","#f87171",'<div style="font-size:.74em;color:#d1d5db;line-height:1.5">'+F("","Spray same-size allocations","")+F("","Attacker data fills freed slot","")+F("","Dangling pointer now reads attacker data","")+'</div>',230);
h+='</div>';
h+='<div class="grd" style="margin-top:8px">';
h+=CRD("\u{1F47B}","UAF Exploitation Strategy","#f87171",F("1.","Trigger allocation of victim object","")+F("2.","Trigger the free (bug: dangling pointer remains)","")+F("3.","Spray same-size objects to reclaim freed slot","")+F("4.","Trigger use of dangling pointer","")+F("5.","Kernel/app reads your controlled data as original object","")+F("6.","If vtable: redirect virtual call to controlled address","")+F("7.","If data: achieve read/write primitive",""));
h+=CRD("\u{1F3AF}","Reclaim Objects (Usermode)","#f87171",F("","Same size is critical: LFH returns same-bucket slots","")+F("","BSTR: SysAllocString with controlled length + content","")+F("","ArrayBuffer (JS): exact size, full content control","")+F("","Typed arrays: Int32Array, Uint8Array for precise layout","")+F("","HTML elements: DOM objects with known size",""));
h+=CRD("\u{1F4BB}","Vtable Hijacking","#f87171",F("","C++ objects: first 8 bytes = vtable pointer","")+F("","Spray with fake vtable pointer in reclaim object","")+F("","When virtual method called: jumps to attacker address","")+F("","With CFG: target must be valid CFG target","")+F("","Without CFG: direct code execution",""));
h+=CRD("\u{1F504}","Double-Free","#f87171",F("","Object freed twice: appears on free list twice","")+F("","Alloc 1 returns slot; alloc 2 returns SAME slot","")+F("","Two live pointers to same memory","")+F("","Modify via pointer A, read via pointer B","")+F("","Equivalent to overlapping allocations",""));
h+='</div>';return h;
}
function fOVF(){
var h='<div style="font-size:.72em;font-weight:800;color:#fbbf24;letter-spacing:.06em;margin-bottom:6px">HEAP OVERFLOW & OUT-OF-BOUNDS</div>';
h+='<div class="grd">';
h+=CRD("\u{1F4A5}","Linear Heap Overflow","#fbbf24",F("","Write past allocation boundary into adjacent chunk","")+F("","Corrupts: next chunk header or next chunk data","")+F("","Header corruption: size/flags/links","")+F("","Data corruption: vtable, function ptrs, lengths","")+F("","Requires: controlled write size past boundary",""));
h+=CRD("\u{1F50D}","Out-of-Bounds Read (Info Leak)","#fbbf24",F("","Read past allocation boundary","")+F("","Leak: adjacent chunk metadata or data","")+F("","Use to: defeat ASLR, leak heap cookies","")+F("","Common in: string operations missing null terminator","")+F("","Or: length confusion (signed vs unsigned)",""));
h+=CRD("\u{1F3AF}","Heap Spray + Overflow","#fbbf24",F("","Spray heap to control adjacent allocations","")+F("","Trigger overflow from controlled chunk into target chunk","")+F("","Target: object with vtable or function pointer","")+F("","LFH randomization complicates but doesn't prevent","")+F("","Strategy: spray thousands, overflow all, one must hit",""));
h+=CRD("\u{1F527}","Metadata Corruption Targets","#fbbf24",F("","_HEAP_ENTRY.Size: change chunk boundary perception","")+F("","FreeList Flink/Blink: classic unlink attack (mitigated)","")+F("","LFH BusyBitmap: create overlapping allocations","")+F("","_HEAP_ENTRY.Flags: make busy appear free","")+F("","Encoding makes direct metadata attacks harder",""));
h+=CRD("\u{1F4CA}","Off-by-One / Off-by-N","#fbbf24",F("","Small overflows (1\u20138 bytes) into header","")+F("","Can corrupt: Size field (change perceived chunk size)","")+F("","Leads to: overlapping chunks on next alloc","")+F("","Null byte overflow: clears encoded size low byte","")+F("","Effect depends on encoding (size XOR cookie)",""));
h+=CRD("\u{1F4BB}","Type Confusion via Overflow","#fbbf24",F("","Overflow modifies type indicator of adjacent object","")+F("","Object is now processed as wrong type","")+F("","Fields at same offsets reinterpreted","")+F("","Can create pointer from integer or vice versa","")+F("","Powerful in JavaScript engines (JIT spray targets)",""));
h+='</div>';return h;
}
function fPRIM(){
var h='<div style="font-size:.72em;font-weight:800;color:#f59e0b;letter-spacing:.06em;margin-bottom:6px">EXPLOITATION PRIMITIVES</div>';
h+='<div class="grd">';
h+=CRD("\u{1F527}","Arbitrary Read","#f59e0b",F("","Goal: read any address in process memory","")+F("","Via: corrupted object length field","")+F("","BSTR: length prefix at -4; corrupt to huge value","")+F("","String read now extends past allocation boundary","")+F("","Or: corrupted typed array buffer pointer",""));
h+=CRD("\u{1F4DD}","Arbitrary Write","#f59e0b",F("","Goal: write any value to any address","")+F("","Via: corrupted typed array backing store pointer","")+F("","Or: corrupted DataView backing buffer","")+F("","ArrayBuffer pointer overwrite \u2192 read/write anywhere","")+F("","Most powerful primitive: enables full exploitation",""));
h+=CRD("\u{1F4CA}","Relative Read/Write","#f59e0b",F("","Read/write within heap region (not arbitrary address)","")+F("","Via: overlapping allocations","")+F("","Corrupt chunk A size \u2192 A covers chunk B","")+F("","Write to A modifies B; read B sees A's writes","")+F("","Upgrade to arbitrary R/W via pointer corruption",""));
h+=CRD("\u{1F3AF}","Info Leak Strategies","#f59e0b",F("","Leak vtable pointer \u2192 defeat ASLR (module base)","")+F("","Leak heap pointer \u2192 predict heap layout","")+F("","Leak cookie \u2192 forge heap metadata","")+F("","Leak stack pointer \u2192 stack pivot target","")+F("","Adjacent free chunk Flink \u2192 heap address",""));
h+=CRD("\u{1F4BB}","Code Execution Paths","#f59e0b",F("","Vtable hijack: overwrite vtable ptr \u2192 fake vtable","")+F("","Function pointer overwrite: callback in object","")+F("","Stack pivot: ROP via overwritten return address","")+F("","CFG bypass needed for indirect calls","")+F("","JIT spray: emit controlled code via JS JIT compiler",""));
h+=CRD("\u{1F500}","Overlapping Allocations","#f59e0b",F("","Two live pointers to same (or overlapping) memory","")+F("","Via: corrupted size, double-free, bitmap corruption","")+F("","Read object A through pointer B","")+F("","Forge object A's contents via pointer B","")+F("","The fundamental building block of modern heap exploits",""));
h+='</div>';return h;
}
function fKIT(){
var h='<div style="font-size:.72em;font-weight:800;color:#e879f9;letter-spacing:.06em;margin-bottom:6px">HEAP ANALYSIS TOOLKIT</div>';
h+='<div class="grd" style="margin-bottom:10px">';
var tools=[
{n:"WinDbg !heap",d:"Built-in heap analysis. !heap -s (summary), !heap -a (all), !heap -flt s SIZE (filter by size). Essential for heap state inspection.",c:"#60a5fa"},
{n:"!heap -p (Page Heap)",d:"Full/light page heap debugging. Detects overflow/UAF at point of corruption. gflags /p /enable app.exe /full to enable.",c:"#34d399"},
{n:"VMMap (Sysinternals)",d:"Visual virtual memory map. Shows heap regions, committed vs reserved, fragmentation patterns. Good for understanding heap layout.",c:"#a78bfa"},
{n:"UMDH (User-Mode Dump Heap)",d:"Tracks allocations with call stacks. Two snapshots + diff = leaked allocations. Built into Windows Debugging Tools.",c:"#f87171"},
{n:"Application Verifier",d:"Detects heap corruption: overflow, underflow, UAF. Inserts guard pages and fill patterns. appverif.exe to configure.",c:"#fbbf24"},
{n:"mona.py / WinDBGlib",d:"Heap analysis scripting. Visualize heap layout, find spray patterns, calculate offsets. Automation for exploit development.",c:"#f59e0b"},
{n:"pwndbg / pwntools (Windows port)",d:"Exploit development helpers. Heap visualization, cyclic patterns, ROP gadget finding. pwntools has Windows remote support.",c:"#e879f9"},
{n:"IDA Heap Tracer",d:"Trace HeapAlloc/HeapFree calls. Map allocation patterns. Identify which code paths control heap layout.",c:"#f472b6"}
];
tools.forEach(function(t){h+='<div style="border-radius:6px;border:1px solid '+t.c+'20;background:'+t.c+'06;padding:5px 8px"><div style="font-weight:700;color:'+t.c+';font-size:.72em">'+t.n+'</div><div style="font-size:.64em;color:#9ca3af;margin-top:1px">'+t.d+'</div></div>';});
h+='</div>';
h+='<div style="font-size:.72em;font-weight:800;color:#e879f9;letter-spacing:.06em;margin:6px 0">WINDBG HEAP COMMANDS</div>';
h+='<div class="grd">';
h+=CRD("\u{1F4BB}","Inspection","#e879f9",F("","!heap -s \u2192 summary of all heaps","")+F("","!heap -h HANDLE \u2192 specific heap details","")+F("","!heap -a ADDR \u2192 analyze specific address","")+F("","!heap -flt s SIZE \u2192 all allocs of given size","")+F("","dt ntdll!_HEAP ADDR \u2192 heap structure",""));
h+=CRD("\u{1F527}","Chunk Analysis","#e879f9",F("","dt ntdll!_HEAP_ENTRY ADDR \u2192 chunk header","")+F("","!heap -x ADDR \u2192 which heap owns this address","")+F("","!heap -p -a ADDR \u2192 page heap details + call stack","")+F("","dt ntdll!_HEAP_SUBSEGMENT \u2192 LFH subsegment","")+F("","dt ntdll!_SEGMENT_HEAP \u2192 segment heap structure",""));
h+='</div>';return h;
}
function fMIT(){
var h='<div style="font-size:.72em;font-weight:800;color:#fb923c;letter-spacing:.06em;margin-bottom:6px">HEAP MITIGATIONS & BYPASS</div>';
h+='<div class="grd">';
h+=CRD("\u{1F6E1}\uFE0F","Heap Metadata Encoding","#fb923c",F("","All _HEAP_ENTRY headers XOR'd with heap cookie","")+F("","Prevents: direct metadata modification via overflow","")+F("","Bypass: info leak to recover encoding key","")+F("","Or: target data corruption instead of metadata",""));
h+=CRD("\u{1F510}","Safe Unlinking","#fb923c",F("","Validates FreeList integrity before unlink","")+F("","Check: Flink->Blink == self && Blink->Flink == self","")+F("","Prevents: classic unlink arbitrary write","")+F("","Since: Windows XP SP2","")+F("","Bypass: corrupt data not metadata; or heap grooming",""));
h+=CRD("\u{1F500}","LFH Randomization","#fb923c",F("","Allocation order randomized within subsegment","")+F("","Prevents: predictable adjacent allocation","")+F("","Bypass: heavy spray (thousands of objects)","")+F("","Statistical: some adjacent pairs guaranteed with enough spray","")+F("","Or: target non-LFH allocations (backend)",""));
h+=CRD("\u{1F4CA}","Guard Pages","#fb923c",F("","Segment Heap: guard pages between segments","")+F("","Page Heap (debug): guard page after every alloc","")+F("","Detects: linear overflow past page boundary","")+F("","Bypass: overflow within same page (small overflow)","")+F("","Page Heap: development/testing only (perf overhead)",""));
h+=CRD("\u{1F3AF}","CFG (Control Flow Guard)","#fb923c",F("","Validates indirect call targets against bitmap","")+F("","Prevents: vtable hijack to arbitrary address","")+F("","Bypass: call existing valid CFG target (reuse)","")+F("","Or: corrupt CFG bitmap (kernel exploit)","")+F("","Or: data-only exploitation (no code pointer hijack)",""));
h+=CRD("\u{1F4BB}","CET (Shadow Stack)","#fb923c",F("","Hardware-enforced return address integrity","")+F("","Prevents: ROP by validating return addresses","")+F("","Bypass: JOP (jump-oriented programming)","")+F("","Or: data-only exploitation paths","")+F("","Win11 22H2+: CET enabled for supported processes",""));
h+='</div>';
h+=N("MODERN EXPLOITATION TREND","#fb923c","With encoding, safe unlink, LFH randomization, CFG, and CET, modern heap exploitation focuses on: <b>data-only attacks</b> (corrupt application data, not metadata), <b>info leaks</b> (defeat ASLR + encoding), and <b>type confusion</b> (reinterpret data as different type). Classic metadata corruption is mostly dead.");
return h;
}
function getCodes(s){
var C={};
C.arc=[
{t:"Determine heap type (NT vs Segment)",l:"c",c:"// Check which heap implementation is active\n// Method 1: WinDbg\n// !heap -s  -> shows heap types\n// dt ntdll!_SEGMENT_HEAP <addr> -> if valid = Segment Heap\n// dt ntdll!_HEAP <addr> -> if valid = NT Heap\n\n// Method 2: Programmatic\n#include <windows.h>\n\nvoid CheckHeapType(void) {\n    HANDLE hHeap = GetProcessHeap();\n    // _HEAP signature at +0x00 = 0xFFEEFFEE (NT Heap)\n    // _SEGMENT_HEAP has different signature\n    DWORD sig = *(DWORD*)hHeap;\n    printf(\"Heap at %p, signature: 0x%08X\\n\", hHeap, sig);\n\n    // Force LFH activation for a size class:\n    ULONG HeapInfo = 2; // HeapCompatibilityInformation\n    HeapSetInformation(hHeap,\n        HeapCompatibilityInformation,\n        &HeapInfo, sizeof(HeapInfo));\n\n    // Activate LFH for specific size:\n    // Allocate 18+ times with same size\n    for (int i = 0; i < 20; i++) {\n        HeapAlloc(hHeap, 0, 0x100);\n    }\n    // Size class 0x100 now served by LFH\n}"}
];
C.nt=[
{t:"NT Heap structure exploration (WinDbg)",l:"bash",c:"// WinDbg commands for NT Heap analysis\n\n// List all heaps:\n!heap -s\n\n// Detailed heap info:\n!heap -h 0  // default heap (index 0)\n\n// Show all free lists:\n!heap -f 0  // free lists for heap 0\n\n// Find allocation by size:\n!heap -flt s 0x100  // all 0x100-byte allocs\n\n// Analyze specific chunk:\n!heap -a 0x01234568\n// Shows: chunk header, flags, size, owner heap\n\n// Decode _HEAP_ENTRY manually:\n// dt ntdll!_HEAP_ENTRY <addr>\n// Fields are XOR-encoded with _HEAP.Encoding\n// To decode: read encoding from heap handle\n// dt ntdll!_HEAP <heapaddr> Encoding\n// Then: decoded_size = encoded_size ^ encoding_size\n\n// LFH subsegment analysis:\n// dt ntdll!_HEAP_SUBSEGMENT <addr>\n// dt ntdll!_HEAP_USERDATA_HEADER <addr>\n// BusyBitmap shows slot usage\n\n// Enable page heap for target:\n// gflags /p /enable target.exe /full\n// Full page heap: guard page after EVERY allocation\n// Catches overflow immediately at point of corruption"}
];
C.seg=[
{t:"Segment Heap VS chunk analysis",l:"bash",c:"// Segment Heap analysis in WinDbg\n\n// Verify Segment Heap active:\ndt ntdll!_SEGMENT_HEAP <heapaddr>\n// If structure resolves: Segment Heap is active\n\n// VS (Variable Size) context:\ndt ntdll!_SEGMENT_HEAP <addr> VsContext\n// Shows: FreeChunkTree (RB tree of free VS chunks)\n\n// Analyze VS chunk:\ndt ntdll!_HEAP_VS_CHUNK_HEADER <chunkaddr>\n// Sizes field is encoded\n// Decode with _SEGMENT_HEAP.EncodingKey\n\n// LFH context (Segment Heap version):\ndt ntdll!_SEGMENT_HEAP <addr> LfhContext\ndt ntdll!_HEAP_LFH_CONTEXT <addr>\ndt ntdll!_HEAP_LFH_SUBSEGMENT <subaddr>\n// Shows bitmap, block size, block count\n\n// Large block context:\ndt ntdll!_SEGMENT_HEAP <addr> LargeAllocMetadata\n// Direct VirtualAlloc for very large allocations\n\n// Find encoding key:\ndt ntdll!_SEGMENT_HEAP <addr> EncodingKey\n// Also: RtlpHpHeapGlobals contains global keys"}
];
C.lfh=[
{t:"Force LFH activation and spray",l:"c",c:"// Force LFH activation for target size class\n// Then spray to control heap layout\n\n#define TARGET_SIZE 0x100\n#define SPRAY_COUNT 5000\n#define HOLE_INTERVAL 8\n\nHANDLE hHeap = GetProcessHeap();\nPVOID allocs[SPRAY_COUNT];\n\n// Step 1: Activate LFH for TARGET_SIZE\nULONG info = 2;\nHeapSetInformation(hHeap,\n    HeapCompatibilityInformation, &info, sizeof(info));\nfor (int i = 0; i < 20; i++) {\n    HeapAlloc(hHeap, 0, TARGET_SIZE);\n}\n// LFH now active for this size class\n\n// Step 2: Spray allocations\nfor (int i = 0; i < SPRAY_COUNT; i++) {\n    allocs[i] = HeapAlloc(hHeap, 0, TARGET_SIZE);\n    // Fill with marker to identify later\n    memset(allocs[i], 0x41 + (i % 26), TARGET_SIZE);\n}\n\n// Step 3: Create holes for target allocation\nfor (int i = 0; i < SPRAY_COUNT; i += HOLE_INTERVAL) {\n    HeapFree(hHeap, 0, allocs[i]);\n    allocs[i] = NULL;\n}\n\n// Step 4: Trigger vulnerable allocation\n// It fills one of our holes\n// Adjacent allocations are our controlled spray objects\nTriggerVulnerableAllocation(TARGET_SIZE);"}
];
C.uaf=[
{t:"UAF reclaim with BSTR objects",l:"c",c:"// Use-After-Free reclaim using BSTR\n// BSTR allows exact size control + content control\n\n#include <oleauto.h>\n\n// Target: freed object of size 0x40\n#define VICTIM_SIZE 0x40\n// BSTR overhead: 4-byte length prefix + 2-byte null term\n// So allocate BSTR of length VICTIM_SIZE - 6\n\nvoid ExploitUAF(void) {\n    // Step 1: Trigger the free (bug-specific)\n    FreeVictimObject(); // dangling pointer remains\n\n    // Step 2: Spray BSTRs to reclaim the slot\n    BSTR sprays[10000];\n    WCHAR payload[VICTIM_SIZE / 2];\n\n    // Craft payload: fake vtable at offset 0\n    *(UINT64*)&payload[0] = FAKE_VTABLE_ADDR;\n    // Fill rest with controlled data\n    for (int i = 4; i < VICTIM_SIZE / 2; i++)\n        payload[i] = 0x4141;\n\n    for (int i = 0; i < 10000; i++) {\n        sprays[i] = SysAllocStringLen(payload,\n            (VICTIM_SIZE - 6) / 2);\n    }\n\n    // Step 3: Trigger use of dangling pointer\n    UseVictimObject();\n    // Virtual call goes to FAKE_VTABLE_ADDR\n}"},
{t:"Double-free overlapping allocation",l:"c",c:"// Double-free: same address returned by two allocations\n\nvoid DoubleFreePrimitive(void) {\n    HANDLE hHeap = GetProcessHeap();\n    SIZE_T size = 0x100;\n\n    // Step 1: Allocate and trigger double free (bug)\n    PVOID chunk = HeapAlloc(hHeap, 0, size);\n    TriggerDoubleFree(chunk);\n    // chunk is now on free list TWICE\n\n    // Step 2: First alloc returns the slot\n    PVOID ptr_A = HeapAlloc(hHeap, 0, size);\n    // ptr_A == chunk (same address)\n\n    // Step 3: Second alloc returns SAME slot\n    PVOID ptr_B = HeapAlloc(hHeap, 0, size);\n    // ptr_B == chunk (same address again!)\n\n    // Now: ptr_A == ptr_B (overlapping)\n    // Write via A, read via B\n    *(UINT64*)ptr_A = 0xDEADBEEF;\n    UINT64 val = *(UINT64*)ptr_B;\n    // val == 0xDEADBEEF\n\n    // Use this for info leak or arbitrary R/W\n    // by placing objects with pointers at known offsets\n}"}
];
C.ovf=[
{t:"Heap overflow into adjacent object",l:"c",c:"// Linear heap overflow: corrupt adjacent chunk\n// Requires: controlled spray for adjacency\n\nvoid HeapOverflowExploit(void) {\n    HANDLE hHeap = GetProcessHeap();\n    SIZE_T size = 0x100;\n\n    // Step 1: Spray to set up heap layout\n    PVOID sprays[5000];\n    for (int i = 0; i < 5000; i++)\n        sprays[i] = HeapAlloc(hHeap, 0, size);\n\n    // Step 2: Free alternating to create holes\n    for (int i = 1; i < 5000; i += 2)\n        HeapFree(hHeap, 0, sprays[i]);\n\n    // Step 3: Place victim objects in holes\n    // Objects with vtable/function pointer at known offset\n    PlaceVictimObjects(size);\n\n    // Step 4: Trigger overflow from our controlled chunk\n    // into adjacent victim object\n    PBYTE vuln = (PBYTE)sprays[100]; // our chunk\n    // Bug: write size+N bytes into size-byte buffer\n    TriggerOverflow(vuln, size + 0x40);\n    // Corrupts first 0x40 bytes of next chunk\n    // If next chunk is victim: vtable overwritten\n\n    // Step 5: Trigger virtual call on victim\n    TriggerVictimVirtualCall();\n    // Redirected to attacker-controlled address\n}"}
];
C.prim=[
{t:"BSTR length corruption for arbitrary read",l:"c",c:"// Corrupt BSTR length prefix for out-of-bounds read\n// BSTR layout: [4-byte length][data...][null term]\n// Length at offset -4 from string pointer\n\n// Step 1: Create overlapping allocations\n// Via: UAF reclaim, double-free, or overflow\n\n// Step 2: Allocate BSTR in overlapping region\nBSTR target = SysAllocStringLen(NULL, 0x20);\n// target[-4] == 0x40 (length in bytes = 0x20 * 2)\n\n// Step 3: Through overlap, corrupt length field\n// Write 0xFFFFFFFF to target[-4]\n*(DWORD*)((PBYTE)target - 4) = 0x7FFFFFFF;\n\n// Step 4: Read past allocation boundary\n// SysStringLen(target) now returns huge value\nfor (DWORD i = 0; i < 0x1000; i++) {\n    WCHAR leaked = target[0x20 + i]; // OOB read\n    // Leaks adjacent heap data:\n    // - vtable pointers (defeat ASLR)\n    // - heap pointers (predict layout)\n    // - encoding keys (forge metadata)\n}\n\n// This gives info leak primitive\n// Use leaked vtable ptr to calculate module base\n// Use leaked heap ptr to target specific allocations"}
];
C.kit=[
{t:"Page heap debugging workflow",l:"bash",c:"// Enable page heap for a target process\n// Full page heap: guard page after every allocation\n// Catches heap overflow AT the point of corruption\n\n// Enable (before starting process):\ngflags /p /enable target.exe /full\n\n// Verify:\ngflags /p\n\n// Run under WinDbg:\nwindbg target.exe\n\n// When overflow occurs:\n// Access violation at guard page\n// !heap -p -a <faulting_addr>\n// Shows: allocation call stack, size, owner\n\n// Useful commands:\n!heap -p -h 0          // page heap summary\n!heap -p -all          // all page heap allocations\n!heap -p -a <addr>     // specific allocation details\n\n// Light page heap (less overhead):\ngflags /p /enable target.exe /light\n// Fills freed memory with pattern (0xFEEEFEEE)\n// Detects UAF on next access (reads bad data)\n// Less precise than full page heap but lower perf hit\n\n// Disable when done:\ngflags /p /disable target.exe\n\n// Application Verifier alternative:\nappverif /verify target.exe\n// GUI: select Heaps checks\n// Provides stack traces on corruption"}
];
C.mit=[
{t:"Modern heap exploitation workflow",l:"c",c:"// Modern exploitation against hardened heap\n// Focus: data corruption, not metadata\n\n// Phase 1: Info Leak\n// - Trigger OOB read (off-by-one, length confusion)\n// - Leak vtable pointer -> defeat ASLR\n// - Leak heap address -> predict spray layout\n// - Leak encoding key -> forge heap metadata (if needed)\n\n// Phase 2: Heap Grooming\n// - Spray target-size allocations (activate LFH)\n// - Create holes at regular intervals\n// - Place victim objects in predicted positions\n// - Key: same-size allocations for LFH bucket grouping\n\n// Phase 3: Corruption Primitive\n// - Trigger bug: overflow, UAF, type confusion\n// - Corrupt APPLICATION DATA, not heap metadata\n// - Target: BSTR length, ArrayBuffer ptr, typed array\n// - Avoid: _HEAP_ENTRY corruption (encoded, validated)\n\n// Phase 4: Arbitrary R/W\n// - Corrupted BSTR length -> relative read\n// - Corrupted ArrayBuffer backing store -> absolute R/W\n// - Or: overlapping allocations -> read/write through other\n\n// Phase 5: Code Execution (if needed)\n// - With CFG: find valid target that gives control\n// - Without CFG: vtable hijack to shellcode/ROP\n// - With CET: data-only attack or JOP\n// - Preferred: corrupt data to achieve goal without code exec"}
];
return C[s]||[];
}
var TR={
arc:[
{t:"NT Heap vs Segment Heap: know your target",d:"Most Win32 apps use NT Heap. Edge, UWP, and system processes use Segment Heap. The exploitation techniques are fundamentally different. Check with !heap -s in WinDbg before developing any exploit."},
{t:"LFH activates automatically after 17 allocations",d:"After 17+ allocations of the same size class, LFH is activated for that bucket. This changes allocation behavior from sequential (back-end) to randomized (LFH). Your exploit strategy must account for this."},
{t:"Heap encoding means you need an info leak first",d:"Every _HEAP_ENTRY header is XOR'd with a per-heap cookie. You cannot directly forge metadata without knowing the cookie. Info leak to recover the encoding key, or avoid metadata corruption entirely."},
{t:"Multiple heaps per process are common",d:"CRT heap, default process heap, COM heaps, custom heaps. Objects on different heaps can't be adjacent. Know which heap your target object is on and spray on the same heap."}
],
nt:[
{t:"Free list coalescing merges adjacent free chunks",d:"When a chunk is freed, the allocator checks if neighbors are also free and merges them. This can destroy your spray layout. Prevent by keeping busy chunks between your holes."},
{t:"Back-end allocations are sequential before LFH",d:"Before LFH activates (first 17 allocs), the back-end serves allocations sequentially from the segment. This is exploitable: adjacent allocations are predictable. Race to exploit before LFH kicks in."},
{t:"Encoded headers make metadata attacks obsolete for most cases",d:"Since Vista, _HEAP_ENTRY is XOR-encoded. Direct metadata corruption (change size, flags, links) requires knowing the encoding. Modern exploits target application data in the chunk, not the chunk header."},
{t:"Safe unlinking killed the classic unlink attack",d:"XP SP2 added Flink->Blink == self validation. Direct arbitrary write via free list manipulation is dead. Modern approach: corrupt data, not metadata; or use type confusion."}
],
seg:[
{t:"VS allocations use a Red-Black tree for free chunks",d:"Segment Heap Variable Size backend stores free chunks in an RB tree sorted by size. Corrupting tree node pointers could redirect allocation, but encoding and validation make this difficult."},
{t:"Segment Heap has more validation than NT Heap",d:"Guard pages, block padding, stricter metadata checks. Segment Heap was designed with security as a primary concern. Exploitation is harder but not impossible with data-only techniques."},
{t:"Block padding adds random bytes after allocation",d:"Segment Heap may add random padding bytes after your requested size. This means the next allocation isn't immediately after your data. Accounts for this in overflow distance calculations."},
{t:"EncodingKey is per-heap and per-boot",d:"The encoding key for VS chunk headers is randomized per heap creation and per boot. It's stored in the _SEGMENT_HEAP structure. You need an info leak to recover it for metadata attacks."}
],
lfh:[
{t:"LFH randomization means spray MORE not less",d:"Since Win8, LFH slot allocation is randomized within subsegments. You can't predict which slot you'll get. Counter: spray thousands of objects. With enough spray, adjacent pairs are statistically guaranteed."},
{t:"Bitmap corruption creates overlapping allocations",d:"If you can reach the LFH BusyBitmap with an overflow, flipping a busy bit to free makes the allocator return an already-in-use slot. Two pointers to the same memory is extremely powerful."},
{t:"Subsegment boundaries are your friend",d:"All blocks in an LFH subsegment are the same size and contiguous. If you spray enough to fill subsegments, you know the relative positions of objects within a subsegment even with randomization."},
{t:"Force LFH activation with HeapSetInformation",d:"Call HeapSetInformation with HeapCompatibilityInformation=2, then allocate 18+ times at your target size. This guarantees LFH is active for your size class. Essential for reliable spray."}
],
uaf:[
{t:"Same size is the golden rule for UAF reclaim",d:"LFH groups allocations by size bucket. To reclaim a freed slot, your spray objects MUST be the exact same size as the freed object. Even 1 byte different and they go to different buckets."},
{t:"BSTR gives exact size control and content control",d:"SysAllocStringLen allocates exactly (len*2 + 6) bytes on the heap with fully controlled content. Perfect for UAF reclaim with fake vtables or forged object data."},
{t:"Time window between free and reclaim matters",d:"If other code allocates between your free and spray, it might reclaim the slot first. Minimize the time window. In browsers: use timing-sensitive JavaScript patterns."},
{t:"Vtable hijacking requires CFG bypass on modern Windows",d:"Even if you successfully reclaim with a fake vtable pointer, CFG validates indirect calls. The target must be a valid CFG target. Or use data-only exploitation to avoid code pointer hijacking entirely."}
],
ovf:[
{t:"Target application data, not heap metadata",d:"Modern heap encoding makes metadata corruption unreliable. Instead: overflow into the next allocation's application data. Corrupt lengths, pointers, type fields in the application object."},
{t:"LFH randomization doesn't prevent all adjacency",d:"With enough spray, some allocations will be adjacent regardless of randomization. If you spray 5000 objects and overflow all of them, many will hit a neighbor. Probabilistic but reliable at scale."},
{t:"Off-by-one into encoded header has unpredictable effects",d:"A null byte overflow into an XOR-encoded _HEAP_ENTRY header creates an unpredictable result (depends on encoding key value). The effect varies per process, per boot. Not reliable."},
{t:"Type confusion is often more powerful than linear overflow",d:"If you can change an object's type indicator, the same memory is reinterpreted with different field layouts. Pointer fields become integers, integers become pointers. Often leads directly to arbitrary R/W."}
],
prim:[
{t:"BSTR length corruption is the classic info leak primitive",d:"Corrupt BSTR length prefix to a huge value. Reading the BSTR now extends past the allocation boundary, leaking adjacent heap data including vtable pointers (ASLR defeat) and heap pointers."},
{t:"ArrayBuffer backing store corruption gives absolute R/W",d:"If you can corrupt the internal pointer of an ArrayBuffer or TypedArray, reads/writes through it go to your chosen address. This is the most powerful exploitation primitive."},
{t:"Overlapping allocations are the fundamental building block",d:"Almost every modern heap exploit works by creating overlapping allocations (two pointers to same memory). The method varies (UAF, double-free, size corruption) but the goal is always overlap."},
{t:"Info leak before exploitation is mandatory on modern Windows",d:"ASLR, heap encoding, CFG bitmaps all require knowledge of runtime addresses. You cannot exploit blind. Always: get info leak first, then use leaked data to construct the actual exploit."}
],
kit:[
{t:"Full page heap catches corruption at the exact point",d:"gflags /p /enable target.exe /full places a guard page after every allocation. Any overflow immediately triggers an access violation with a full call stack. Essential for initial bug analysis."},
{t:"!heap -flt s SIZE finds all allocations of a given size",d:"When developing exploits, you need to know what else lives at your target size class. This command shows all current allocations of that size, helping you understand what you might corrupt."},
{t:"Application Verifier is underrated for heap debugging",d:"Provides fill patterns on free (detect UAF), delay-free (make UAF window wider), guard pages, and detailed logging. More features than gflags page heap alone."},
{t:"Trace allocation call stacks with UMDH",d:"Take two UMDH snapshots and diff them. Shows: which allocations grew, which leaked, with full call stacks. Essential for understanding heap behavior of complex applications."}
],
mit:[
{t:"Data-only exploitation is the future",d:"With encoding, safe unlink, CFG, and CET, metadata corruption and code pointer hijacking are increasingly difficult. Modern exploits corrupt application data to achieve goals without ever executing shellcode."},
{t:"CFG is bypassable but adds significant complexity",d:"You can only call valid CFG targets. This limits vtable hijacking to functions already in the bitmap. Finding useful valid targets (gadgets within CFG-valid functions) is the challenge."},
{t:"CET shadow stack blocks traditional ROP",d:"Return addresses validated against hardware shadow stack. ROP chains fail because modified return addresses don't match. Alternative: JOP, data-only attacks, or find CET-exempt code paths."},
{t:"Segment Heap is harder but not impossible",d:"More validation, encoding, guard pages. But the fundamental vulnerability classes (UAF, overflow, type confusion) still apply. The exploitation path is longer but the bug classes are the same."}
]
};
function render(){
var si=SE.findIndex(function(x){return x.id===S.s}),so=SE[si];
var codes=getCodes(S.s),tricks=TR[S.s]||[];
var flow='';
if(S.s==='arc')flow=fARC();else if(S.s==='nt')flow=fNT();else if(S.s==='seg')flow=fSEG();
else if(S.s==='lfh')flow=fLFH();else if(S.s==='uaf')flow=fUAF();else if(S.s==='ovf')flow=fOVF();
else if(S.s==='prim')flow=fPRIM();else if(S.s==='kit')flow=fKIT();else if(S.s==='mit')flow=fMIT();
var chtml=codes.length===0?'<div style="color:#4b5563;padding:16px;text-align:center">No code examples.</div>':
codes.map(function(c,i){return'<div class="cp" data-ci="'+i+'"><button class="ct2"><span class="cv">&#9654;</span><span class="tl">'+c.t+'</span>'+T(c.l,"#6b7280",1)+'</button></div>'}).join('');
var thtml=tricks.length===0?'':
'<div style="font-size:.68em;font-weight:800;color:#f97316;letter-spacing:.08em;margin-bottom:6px">TRADECRAFT</div>'+
tricks.map(function(t,i){return'<div class="ti" data-ti="'+i+'"><button class="tt"><span class="cv" style="color:#f97316;font-size:10px">&#9654;</span><span class="tn">'+t.t+'</span></button></div>'}).join('');
var pv=si>0?'<button class="nb2" data-nv="'+SE[si-1].id+'">\u2190 '+SE[si-1].l+'</button>':'';
var nx=si<SE.length-1?'<button class="nb2" data-nv="'+SE[si+1].id+'">'+SE[si+1].l+' \u2192</button>':'';
$('#app').innerHTML=
'<div class="hd"><div style="display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:8px;margin-bottom:6px"><div><h1>Heap Exploitation (Windows) Reference</h1><div class="sub">Architecture \u2022 NT Heap \u2022 Segment Heap \u2022 LFH \u2022 UAF \u2022 Overflow \u2022 Primitives \u2022 Toolkit \u2022 Mitigations</div></div></div><div class="st">'+
SE.map(function(s){return'<button class="sb'+(S.s===s.id?' on':'')+'" style="'+(S.s===s.id?'color:'+s.c+';border-bottom-color:'+s.c:'')+'" data-sc="'+s.id+'">'+s.i+' '+s.l+'</button>'}).join('')+
'</div></div><div class="ut"><button class="ub'+(S.t==='flow'?' on':'')+'" data-tb="flow">\u{1F4CA} Flow</button><button class="ub'+(S.t==='code'?' on':'')+'" data-tb="code">\u{1F4BB} Code'+(codes.length?' <span class="cnt">'+codes.length+'</span>':'')+'</button><button class="ub'+(S.t==='tricks'?' on':'')+'" data-tb="tricks">\u{1F512} Tradecraft'+(tricks.length?' <span class="cnt">'+tricks.length+'</span>':'')+'</button></div>'+
'<div class="ct"><div style="display:flex;align-items:center;gap:6px;margin-bottom:6px"><span style="font-size:1em">'+so.i+'</span><h2 style="font-size:.9em;font-weight:700">'+so.l+'</h2>'+T(so.l,so.c)+'<div style="margin-left:auto;display:flex;gap:3px">'+pv+nx+'</div></div>'+
'<div id="tf" style="'+(S.t!=='flow'?'display:none':'')+'">'+flow+'</div>'+
'<div id="tc" style="'+(S.t!=='code'?'display:none':'')+'">'+chtml+'</div>'+
'<div id="tt" style="'+(S.t!=='tricks'?'display:none':'')+'">'+thtml+'</div></div>'+
'<div class="ft">'+[{c:"#f472b6",l:"Architecture"},{c:"#60a5fa",l:"NT Heap"},{c:"#a78bfa",l:"Segment Heap"},{c:"#34d399",l:"LFH"},{c:"#f87171",l:"UAF"},{c:"#fbbf24",l:"Overflow"},{c:"#f59e0b",l:"Primitives"},{c:"#e879f9",l:"Toolkit"},{c:"#fb923c",l:"Mitigations"}].map(function(x){return'<div style="display:flex;align-items:center;gap:3px"><span class="dt" style="background:'+x.c+'"></span><span style="color:#4b5563">'+x.l+'</span></div>'}).join('')+'</div>';
$$('[data-sc]').forEach(function(b){b.onclick=function(){S.s=b.dataset.sc;S.t='flow';render()}});
$$('[data-tb]').forEach(function(b){b.onclick=function(){S.t=b.dataset.tb;render()}});
$$('[data-nv]').forEach(function(b){b.onclick=function(){S.s=b.dataset.nv;S.t='flow';render()}});
$$('.cp').forEach(function(p){
p.querySelector('.ct2').onclick=function(){
var ex=p.querySelector('.cb'),cv=p.querySelector('.cv');
if(ex){ex.remove();cv.classList.remove('op');return}
cv.classList.add('op');
var ci=parseInt(p.dataset.ci),c=codes[ci];
var pre=document.createElement('pre');pre.className='cb mono';
pre.innerHTML=c.c.split('\n').map(function(line){
var ci2=line.indexOf('//');if(ci2<0)ci2=line.indexOf('#');
if(ci2>=0)return esc(line.slice(0,ci2))+'<span class="cm">'+esc(line.slice(ci2))+'</span>';
return esc(line);
}).join('\n');
p.appendChild(pre);};
});
$$('.ti').forEach(function(p){
p.querySelector('.tt').onclick=function(){
var ex=p.querySelector('.td'),cv=p.querySelector('.cv');
if(ex){ex.remove();p.classList.remove('op');cv.classList.remove('op');return}
p.classList.add('op');cv.classList.add('op');
var ti=parseInt(p.dataset.ti);
var div=document.createElement('div');div.className='td';div.textContent=tricks[ti].d;
p.appendChild(div);};
});
}
render();
</script>
</body>
</html>
